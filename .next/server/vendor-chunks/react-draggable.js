"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-draggable";
exports.ids = ["vendor-chunks/react-draggable"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-draggable/build/cjs/Draggable.js":
/*!*************************************************************!*\
  !*** ./node_modules/react-draggable/build/cjs/Draggable.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"DraggableCore\", ({\n    enumerable: true,\n    get: function() {\n        return _DraggableCore.default;\n    }\n}));\nexports[\"default\"] = void 0;\nvar React = _interopRequireWildcard(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"));\nvar _propTypes = _interopRequireDefault(__webpack_require__(/*! prop-types */ \"(ssr)/./node_modules/prop-types/index.js\"));\nvar _reactDom = _interopRequireDefault(__webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\"));\nvar _clsx = __webpack_require__(/*! clsx */ \"(ssr)/./node_modules/clsx/dist/clsx.js\");\nvar _domFns = __webpack_require__(/*! ./utils/domFns */ \"(ssr)/./node_modules/react-draggable/build/cjs/utils/domFns.js\");\nvar _positionFns = __webpack_require__(/*! ./utils/positionFns */ \"(ssr)/./node_modules/react-draggable/build/cjs/utils/positionFns.js\");\nvar _shims = __webpack_require__(/*! ./utils/shims */ \"(ssr)/./node_modules/react-draggable/build/cjs/utils/shims.js\");\nvar _DraggableCore = _interopRequireDefault(__webpack_require__(/*! ./DraggableCore */ \"(ssr)/./node_modules/react-draggable/build/cjs/DraggableCore.js\"));\nvar _log = _interopRequireDefault(__webpack_require__(/*! ./utils/log */ \"(ssr)/./node_modules/react-draggable/build/cjs/utils/log.js\"));\nfunction _interopRequireDefault(e) {\n    return e && e.__esModule ? e : {\n        default: e\n    };\n}\nfunction _interopRequireWildcard(e, t) {\n    if (\"function\" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap();\n    return (_interopRequireWildcard = function(e, t) {\n        if (!t && e && e.__esModule) return e;\n        var o, i, f = {\n            __proto__: null,\n            default: e\n        };\n        if (null === e || \"object\" != typeof e && \"function\" != typeof e) return f;\n        if (o = t ? n : r) {\n            if (o.has(e)) return o.get(e);\n            o.set(e, f);\n        }\n        for(const t in e)\"default\" !== t && ({}).hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]);\n        return f;\n    })(e, t);\n}\nfunction _extends() {\n    return _extends = Object.assign ? Object.assign.bind() : function(n) {\n        for(var e = 1; e < arguments.length; e++){\n            var t = arguments[e];\n            for(var r in t)({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);\n        }\n        return n;\n    }, _extends.apply(null, arguments);\n}\nfunction _defineProperty(e, r, t) {\n    return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n        value: t,\n        enumerable: !0,\n        configurable: !0,\n        writable: !0\n    }) : e[r] = t, e;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == typeof i ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != typeof t || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != typeof i) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n} /*:: import type {ControlPosition, PositionOffsetControlPosition, DraggableCoreProps, DraggableCoreDefaultProps} from './DraggableCore';*/ \n/*:: import type {Bounds, DraggableEventHandler} from './utils/types';*/ /*:: import type {Element as ReactElement} from 'react';*/ /*:: type DraggableState = {\n  dragging: boolean,\n  dragged: boolean,\n  x: number, y: number,\n  slackX: number, slackY: number,\n  isElementSVG: boolean,\n  prevPropsPosition: ?ControlPosition,\n};*/ /*:: export type DraggableDefaultProps = {\n  ...DraggableCoreDefaultProps,\n  axis: 'both' | 'x' | 'y' | 'none',\n  bounds: Bounds | string | false,\n  defaultClassName: string,\n  defaultClassNameDragging: string,\n  defaultClassNameDragged: string,\n  defaultPosition: ControlPosition,\n  scale: number,\n};*/ /*:: export type DraggableProps = {\n  ...DraggableCoreProps,\n  ...DraggableDefaultProps,\n  positionOffset: PositionOffsetControlPosition,\n  position: ControlPosition,\n};*/ //\n// Define <Draggable>\n//\nclass Draggable extends React.Component /*:: <DraggableProps, DraggableState>*/  {\n    // React 16.3+\n    // Arity (props, state)\n    static getDerivedStateFromProps(_ref /*:: */ , _ref2 /*:: */ ) /*: ?Partial<DraggableState>*/ {\n        let { position } /*: DraggableProps*/  = _ref /*: DraggableProps*/ ;\n        let { prevPropsPosition } /*: DraggableState*/  = _ref2 /*: DraggableState*/ ;\n        // Set x/y if a new position is provided in props that is different than the previous.\n        if (position && (!prevPropsPosition || position.x !== prevPropsPosition.x || position.y !== prevPropsPosition.y)) {\n            (0, _log.default)(\"Draggable: getDerivedStateFromProps %j\", {\n                position,\n                prevPropsPosition\n            });\n            return {\n                x: position.x,\n                y: position.y,\n                prevPropsPosition: {\n                    ...position\n                }\n            };\n        }\n        return null;\n    }\n    constructor(props /*: DraggableProps*/ ){\n        super(props);\n        _defineProperty(this, \"onDragStart\", (e, coreData)=>{\n            (0, _log.default)(\"Draggable: onDragStart: %j\", coreData);\n            // Short-circuit if user's callback killed it.\n            const shouldStart = this.props.onStart(e, (0, _positionFns.createDraggableData)(this, coreData));\n            // Kills start event on core as well, so move handlers are never bound.\n            if (shouldStart === false) return false;\n            this.setState({\n                dragging: true,\n                dragged: true\n            });\n        });\n        _defineProperty(this, \"onDrag\", (e, coreData)=>{\n            if (!this.state.dragging) return false;\n            (0, _log.default)(\"Draggable: onDrag: %j\", coreData);\n            const uiData = (0, _positionFns.createDraggableData)(this, coreData);\n            const newState = {\n                x: uiData.x,\n                y: uiData.y,\n                slackX: 0,\n                slackY: 0\n            };\n            // Keep within bounds.\n            if (this.props.bounds) {\n                // Save original x and y.\n                const { x, y } = newState;\n                // Add slack to the values used to calculate bound position. This will ensure that if\n                // we start removing slack, the element won't react to it right away until it's been\n                // completely removed.\n                newState.x += this.state.slackX;\n                newState.y += this.state.slackY;\n                // Get bound position. This will ceil/floor the x and y within the boundaries.\n                const [newStateX, newStateY] = (0, _positionFns.getBoundPosition)(this, newState.x, newState.y);\n                newState.x = newStateX;\n                newState.y = newStateY;\n                // Recalculate slack by noting how much was shaved by the boundPosition handler.\n                newState.slackX = this.state.slackX + (x - newState.x);\n                newState.slackY = this.state.slackY + (y - newState.y);\n                // Update the event we fire to reflect what really happened after bounds took effect.\n                uiData.x = newState.x;\n                uiData.y = newState.y;\n                uiData.deltaX = newState.x - this.state.x;\n                uiData.deltaY = newState.y - this.state.y;\n            }\n            // Short-circuit if user's callback killed it.\n            const shouldUpdate = this.props.onDrag(e, uiData);\n            if (shouldUpdate === false) return false;\n            this.setState(newState);\n        });\n        _defineProperty(this, \"onDragStop\", (e, coreData)=>{\n            if (!this.state.dragging) return false;\n            // Short-circuit if user's callback killed it.\n            const shouldContinue = this.props.onStop(e, (0, _positionFns.createDraggableData)(this, coreData));\n            if (shouldContinue === false) return false;\n            (0, _log.default)(\"Draggable: onDragStop: %j\", coreData);\n            const newState /*: Partial<DraggableState>*/  = {\n                dragging: false,\n                slackX: 0,\n                slackY: 0\n            };\n            // If this is a controlled component, the result of this operation will be to\n            // revert back to the old position. We expect a handler on `onDragStop`, at the least.\n            const controlled = Boolean(this.props.position);\n            if (controlled) {\n                const { x, y } = this.props.position;\n                newState.x = x;\n                newState.y = y;\n            }\n            this.setState(newState);\n        });\n        this.state = {\n            // Whether or not we are currently dragging.\n            dragging: false,\n            // Whether or not we have been dragged before.\n            dragged: false,\n            // Current transform x and y.\n            x: props.position ? props.position.x : props.defaultPosition.x,\n            y: props.position ? props.position.y : props.defaultPosition.y,\n            prevPropsPosition: {\n                ...props.position\n            },\n            // Used for compensating for out-of-bounds drags\n            slackX: 0,\n            slackY: 0,\n            // Can only determine if SVG after mounting\n            isElementSVG: false\n        };\n        if (props.position && !(props.onDrag || props.onStop)) {\n            // eslint-disable-next-line no-console\n            console.warn(\"A `position` was applied to this <Draggable>, without drag handlers. This will make this \" + \"component effectively undraggable. Please attach `onDrag` or `onStop` handlers so you can adjust the \" + \"`position` of this element.\");\n        }\n    }\n    componentDidMount() {\n        // Check to see if the element passed is an instanceof SVGElement\n        if (typeof window.SVGElement !== \"undefined\" && this.findDOMNode() instanceof window.SVGElement) {\n            this.setState({\n                isElementSVG: true\n            });\n        }\n    }\n    componentWillUnmount() {\n        if (this.state.dragging) {\n            this.setState({\n                dragging: false\n            }); // prevents invariant if unmounted while dragging\n        }\n    }\n    // React Strict Mode compatibility: if `nodeRef` is passed, we will use it instead of trying to find\n    // the underlying DOM node ourselves. See the README for more information.\n    findDOMNode() /*: ?HTMLElement*/ {\n        return this.props?.nodeRef?.current ?? _reactDom.default.findDOMNode(this);\n    }\n    render() /*: ReactElement<any>*/ {\n        const { axis, bounds, children, defaultPosition, defaultClassName, defaultClassNameDragging, defaultClassNameDragged, position, positionOffset, scale, ...draggableCoreProps } = this.props;\n        let style = {};\n        let svgTransform = null;\n        // If this is controlled, we don't want to move it - unless it's dragging.\n        const controlled = Boolean(position);\n        const draggable = !controlled || this.state.dragging;\n        const validPosition = position || defaultPosition;\n        const transformOpts = {\n            // Set left if horizontal drag is enabled\n            x: (0, _positionFns.canDragX)(this) && draggable ? this.state.x : validPosition.x,\n            // Set top if vertical drag is enabled\n            y: (0, _positionFns.canDragY)(this) && draggable ? this.state.y : validPosition.y\n        };\n        // If this element was SVG, we use the `transform` attribute.\n        if (this.state.isElementSVG) {\n            svgTransform = (0, _domFns.createSVGTransform)(transformOpts, positionOffset);\n        } else {\n            // Add a CSS transform to move the element around. This allows us to move the element around\n            // without worrying about whether or not it is relatively or absolutely positioned.\n            // If the item you are dragging already has a transform set, wrap it in a <span> so <Draggable>\n            // has a clean slate.\n            style = (0, _domFns.createCSSTransform)(transformOpts, positionOffset);\n        }\n        // Mark with class while dragging\n        const className = (0, _clsx.clsx)(children.props.className || \"\", defaultClassName, {\n            [defaultClassNameDragging]: this.state.dragging,\n            [defaultClassNameDragged]: this.state.dragged\n        });\n        // Reuse the child provided\n        // This makes it flexible to use whatever element is wanted (div, ul, etc)\n        return /*#__PURE__*/ React.createElement(_DraggableCore.default, _extends({}, draggableCoreProps, {\n            onStart: this.onDragStart,\n            onDrag: this.onDrag,\n            onStop: this.onDragStop\n        }), /*#__PURE__*/ React.cloneElement(React.Children.only(children), {\n            className: className,\n            style: {\n                ...children.props.style,\n                ...style\n            },\n            transform: svgTransform\n        }));\n    }\n}\nexports[\"default\"] = Draggable;\n_defineProperty(Draggable, \"displayName\", \"Draggable\");\n_defineProperty(Draggable, \"propTypes\", {\n    // Accepts all props <DraggableCore> accepts.\n    ..._DraggableCore.default.propTypes,\n    /**\n   * `axis` determines which axis the draggable can move.\n   *\n   *  Note that all callbacks will still return data as normal. This only\n   *  controls flushing to the DOM.\n   *\n   * 'both' allows movement horizontally and vertically.\n   * 'x' limits movement to horizontal axis.\n   * 'y' limits movement to vertical axis.\n   * 'none' limits all movement.\n   *\n   * Defaults to 'both'.\n   */ axis: _propTypes.default.oneOf([\n        \"both\",\n        \"x\",\n        \"y\",\n        \"none\"\n    ]),\n    /**\n   * `bounds` determines the range of movement available to the element.\n   * Available values are:\n   *\n   * 'parent' restricts movement within the Draggable's parent node.\n   *\n   * Alternatively, pass an object with the following properties, all of which are optional:\n   *\n   * {left: LEFT_BOUND, right: RIGHT_BOUND, bottom: BOTTOM_BOUND, top: TOP_BOUND}\n   *\n   * All values are in px.\n   *\n   * Example:\n   *\n   * ```jsx\n   *   let App = React.createClass({\n   *       render: function () {\n   *         return (\n   *            <Draggable bounds={{right: 300, bottom: 300}}>\n   *              <div>Content</div>\n   *           </Draggable>\n   *         );\n   *       }\n   *   });\n   * ```\n   */ bounds: _propTypes.default.oneOfType([\n        _propTypes.default.shape({\n            left: _propTypes.default.number,\n            right: _propTypes.default.number,\n            top: _propTypes.default.number,\n            bottom: _propTypes.default.number\n        }),\n        _propTypes.default.string,\n        _propTypes.default.oneOf([\n            false\n        ])\n    ]),\n    defaultClassName: _propTypes.default.string,\n    defaultClassNameDragging: _propTypes.default.string,\n    defaultClassNameDragged: _propTypes.default.string,\n    /**\n   * `defaultPosition` specifies the x and y that the dragged item should start at\n   *\n   * Example:\n   *\n   * ```jsx\n   *      let App = React.createClass({\n   *          render: function () {\n   *              return (\n   *                  <Draggable defaultPosition={{x: 25, y: 25}}>\n   *                      <div>I start with transformX: 25px and transformY: 25px;</div>\n   *                  </Draggable>\n   *              );\n   *          }\n   *      });\n   * ```\n   */ defaultPosition: _propTypes.default.shape({\n        x: _propTypes.default.number,\n        y: _propTypes.default.number\n    }),\n    positionOffset: _propTypes.default.shape({\n        x: _propTypes.default.oneOfType([\n            _propTypes.default.number,\n            _propTypes.default.string\n        ]),\n        y: _propTypes.default.oneOfType([\n            _propTypes.default.number,\n            _propTypes.default.string\n        ])\n    }),\n    /**\n   * `position`, if present, defines the current position of the element.\n   *\n   *  This is similar to how form elements in React work - if no `position` is supplied, the component\n   *  is uncontrolled.\n   *\n   * Example:\n   *\n   * ```jsx\n   *      let App = React.createClass({\n   *          render: function () {\n   *              return (\n   *                  <Draggable position={{x: 25, y: 25}}>\n   *                      <div>I start with transformX: 25px and transformY: 25px;</div>\n   *                  </Draggable>\n   *              );\n   *          }\n   *      });\n   * ```\n   */ position: _propTypes.default.shape({\n        x: _propTypes.default.number,\n        y: _propTypes.default.number\n    }),\n    /**\n   * These properties should be defined on the child, not here.\n   */ className: _shims.dontSetMe,\n    style: _shims.dontSetMe,\n    transform: _shims.dontSetMe\n});\n_defineProperty(Draggable, \"defaultProps\", {\n    ..._DraggableCore.default.defaultProps,\n    axis: \"both\",\n    bounds: false,\n    defaultClassName: \"react-draggable\",\n    defaultClassNameDragging: \"react-draggable-dragging\",\n    defaultClassNameDragged: \"react-draggable-dragged\",\n    defaultPosition: {\n        x: 0,\n        y: 0\n    },\n    scale: 1\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtZHJhZ2dhYmxlL2J1aWxkL2Nqcy9EcmFnZ2FibGUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYkEsOENBQTZDO0lBQzNDRyxPQUFPO0FBQ1QsQ0FBQyxFQUFDO0FBQ0ZILGlEQUFnRDtJQUM5Q0ksWUFBWTtJQUNaQyxLQUFLO1FBQ0gsT0FBT0MsZUFBZUMsT0FBTztJQUMvQjtBQUNGLENBQUMsRUFBQztBQUNGTCxrQkFBZSxHQUFHLEtBQUs7QUFDdkIsSUFBSU0sUUFBUUMsd0JBQXdCQyxtQkFBT0EsQ0FBQyx3R0FBTztBQUNuRCxJQUFJQyxhQUFhQyx1QkFBdUJGLG1CQUFPQSxDQUFDLDREQUFZO0FBQzVELElBQUlHLFlBQVlELHVCQUF1QkYsbUJBQU9BLENBQUMsZ0hBQVc7QUFDMUQsSUFBSUksUUFBUUosbUJBQU9BLENBQUMsb0RBQU07QUFDMUIsSUFBSUssVUFBVUwsbUJBQU9BLENBQUMsc0ZBQWdCO0FBQ3RDLElBQUlNLGVBQWVOLG1CQUFPQSxDQUFDLGdHQUFxQjtBQUNoRCxJQUFJTyxTQUFTUCxtQkFBT0EsQ0FBQyxvRkFBZTtBQUNwQyxJQUFJSixpQkFBaUJNLHVCQUF1QkYsbUJBQU9BLENBQUMsd0ZBQWlCO0FBQ3JFLElBQUlRLE9BQU9OLHVCQUF1QkYsbUJBQU9BLENBQUMsZ0ZBQWE7QUFDdkQsU0FBU0UsdUJBQXVCTyxDQUFDO0lBQUksT0FBT0EsS0FBS0EsRUFBRUMsVUFBVSxHQUFHRCxJQUFJO1FBQUVaLFNBQVNZO0lBQUU7QUFBRztBQUNwRixTQUFTVix3QkFBd0JVLENBQUMsRUFBRUUsQ0FBQztJQUFJLElBQUksY0FBYyxPQUFPQyxTQUFTLElBQUlDLElBQUksSUFBSUQsV0FBV0UsSUFBSSxJQUFJRjtJQUFXLE9BQU8sQ0FBQ2IsMEJBQTBCLFNBQVVVLENBQUMsRUFBRUUsQ0FBQztRQUFJLElBQUksQ0FBQ0EsS0FBS0YsS0FBS0EsRUFBRUMsVUFBVSxFQUFFLE9BQU9EO1FBQUcsSUFBSU0sR0FB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LGdCQUFnQlUsV0FBVyxnQkFBZ0I7SUFDekMsR0FBRzVDLGVBQWVDLE9BQU8sQ0FBQytILFlBQVk7SUFDdENyQyxNQUFNO0lBQ054QixRQUFRO0lBQ1IwQixrQkFBa0I7SUFDbEJDLDBCQUEwQjtJQUMxQkMseUJBQXlCO0lBQ3pCaEIsaUJBQWlCO1FBQ2Y1QixHQUFHO1FBQ0hDLEdBQUc7SUFDTDtJQUNBNkMsT0FBTztBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWktb3MtbXZwLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRyYWdnYWJsZS9idWlsZC9janMvRHJhZ2dhYmxlLmpzPzdlMmMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJEcmFnZ2FibGVDb3JlXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9EcmFnZ2FibGVDb3JlLmRlZmF1bHQ7XG4gIH1cbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xudmFyIFJlYWN0ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciBfcHJvcFR5cGVzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwicHJvcC10eXBlc1wiKSk7XG52YXIgX3JlYWN0RG9tID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwicmVhY3QtZG9tXCIpKTtcbnZhciBfY2xzeCA9IHJlcXVpcmUoXCJjbHN4XCIpO1xudmFyIF9kb21GbnMgPSByZXF1aXJlKFwiLi91dGlscy9kb21GbnNcIik7XG52YXIgX3Bvc2l0aW9uRm5zID0gcmVxdWlyZShcIi4vdXRpbHMvcG9zaXRpb25GbnNcIik7XG52YXIgX3NoaW1zID0gcmVxdWlyZShcIi4vdXRpbHMvc2hpbXNcIik7XG52YXIgX0RyYWdnYWJsZUNvcmUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL0RyYWdnYWJsZUNvcmVcIikpO1xudmFyIF9sb2cgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3V0aWxzL2xvZ1wiKSk7XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KGUpIHsgcmV0dXJuIGUgJiYgZS5fX2VzTW9kdWxlID8gZSA6IHsgZGVmYXVsdDogZSB9OyB9XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChlLCB0KSB7IGlmIChcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFdlYWtNYXApIHZhciByID0gbmV3IFdlYWtNYXAoKSwgbiA9IG5ldyBXZWFrTWFwKCk7IHJldHVybiAoX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQgPSBmdW5jdGlvbiAoZSwgdCkgeyBpZiAoIXQgJiYgZSAmJiBlLl9fZXNNb2R1bGUpIHJldHVybiBlOyB2YXIgbywgaSwgZiA9IHsgX19wcm90b19fOiBudWxsLCBkZWZhdWx0OiBlIH07IGlmIChudWxsID09PSBlIHx8IFwib2JqZWN0XCIgIT0gdHlwZW9mIGUgJiYgXCJmdW5jdGlvblwiICE9IHR5cGVvZiBlKSByZXR1cm4gZjsgaWYgKG8gPSB0ID8gbiA6IHIpIHsgaWYgKG8uaGFzKGUpKSByZXR1cm4gby5nZXQoZSk7IG8uc2V0KGUsIGYpOyB9IGZvciAoY29uc3QgdCBpbiBlKSBcImRlZmF1bHRcIiAhPT0gdCAmJiB7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsIHQpICYmICgoaSA9IChvID0gT2JqZWN0LmRlZmluZVByb3BlcnR5KSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHQpKSAmJiAoaS5nZXQgfHwgaS5zZXQpID8gbyhmLCB0LCBpKSA6IGZbdF0gPSBlW3RdKTsgcmV0dXJuIGY7IH0pKGUsIHQpOyB9XG5mdW5jdGlvbiBfZXh0ZW5kcygpIHsgcmV0dXJuIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiA/IE9iamVjdC5hc3NpZ24uYmluZCgpIDogZnVuY3Rpb24gKG4pIHsgZm9yICh2YXIgZSA9IDE7IGUgPCBhcmd1bWVudHMubGVuZ3RoOyBlKyspIHsgdmFyIHQgPSBhcmd1bWVudHNbZV07IGZvciAodmFyIHIgaW4gdCkgKHt9KS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsIHIpICYmIChuW3JdID0gdFtyXSk7IH0gcmV0dXJuIG47IH0sIF9leHRlbmRzLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0KSB7IHJldHVybiAociA9IF90b1Byb3BlcnR5S2V5KHIpKSBpbiBlID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIHsgdmFsdWU6IHQsIGVudW1lcmFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwLCB3cml0YWJsZTogITAgfSkgOiBlW3JdID0gdCwgZTsgfVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkodCkgeyB2YXIgaSA9IF90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTsgcmV0dXJuIFwic3ltYm9sXCIgPT0gdHlwZW9mIGkgPyBpIDogaSArIFwiXCI7IH1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7IGlmIChcIm9iamVjdFwiICE9IHR5cGVvZiB0IHx8ICF0KSByZXR1cm4gdDsgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmICh2b2lkIDAgIT09IGUpIHsgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7IGlmIChcIm9iamVjdFwiICE9IHR5cGVvZiBpKSByZXR1cm4gaTsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7IH0gLyo6OiBpbXBvcnQgdHlwZSB7Q29udHJvbFBvc2l0aW9uLCBQb3NpdGlvbk9mZnNldENvbnRyb2xQb3NpdGlvbiwgRHJhZ2dhYmxlQ29yZVByb3BzLCBEcmFnZ2FibGVDb3JlRGVmYXVsdFByb3BzfSBmcm9tICcuL0RyYWdnYWJsZUNvcmUnOyovXG4vKjo6IGltcG9ydCB0eXBlIHtCb3VuZHMsIERyYWdnYWJsZUV2ZW50SGFuZGxlcn0gZnJvbSAnLi91dGlscy90eXBlcyc7Ki9cbi8qOjogaW1wb3J0IHR5cGUge0VsZW1lbnQgYXMgUmVhY3RFbGVtZW50fSBmcm9tICdyZWFjdCc7Ki9cbi8qOjogdHlwZSBEcmFnZ2FibGVTdGF0ZSA9IHtcbiAgZHJhZ2dpbmc6IGJvb2xlYW4sXG4gIGRyYWdnZWQ6IGJvb2xlYW4sXG4gIHg6IG51bWJlciwgeTogbnVtYmVyLFxuICBzbGFja1g6IG51bWJlciwgc2xhY2tZOiBudW1iZXIsXG4gIGlzRWxlbWVudFNWRzogYm9vbGVhbixcbiAgcHJldlByb3BzUG9zaXRpb246ID9Db250cm9sUG9zaXRpb24sXG59OyovXG4vKjo6IGV4cG9ydCB0eXBlIERyYWdnYWJsZURlZmF1bHRQcm9wcyA9IHtcbiAgLi4uRHJhZ2dhYmxlQ29yZURlZmF1bHRQcm9wcyxcbiAgYXhpczogJ2JvdGgnIHwgJ3gnIHwgJ3knIHwgJ25vbmUnLFxuICBib3VuZHM6IEJvdW5kcyB8IHN0cmluZyB8IGZhbHNlLFxuICBkZWZhdWx0Q2xhc3NOYW1lOiBzdHJpbmcsXG4gIGRlZmF1bHRDbGFzc05hbWVEcmFnZ2luZzogc3RyaW5nLFxuICBkZWZhdWx0Q2xhc3NOYW1lRHJhZ2dlZDogc3RyaW5nLFxuICBkZWZhdWx0UG9zaXRpb246IENvbnRyb2xQb3NpdGlvbixcbiAgc2NhbGU6IG51bWJlcixcbn07Ki9cbi8qOjogZXhwb3J0IHR5cGUgRHJhZ2dhYmxlUHJvcHMgPSB7XG4gIC4uLkRyYWdnYWJsZUNvcmVQcm9wcyxcbiAgLi4uRHJhZ2dhYmxlRGVmYXVsdFByb3BzLFxuICBwb3NpdGlvbk9mZnNldDogUG9zaXRpb25PZmZzZXRDb250cm9sUG9zaXRpb24sXG4gIHBvc2l0aW9uOiBDb250cm9sUG9zaXRpb24sXG59OyovXG4vL1xuLy8gRGVmaW5lIDxEcmFnZ2FibGU+XG4vL1xuY2xhc3MgRHJhZ2dhYmxlIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IC8qOjogPERyYWdnYWJsZVByb3BzLCBEcmFnZ2FibGVTdGF0ZT4qL3tcbiAgLy8gUmVhY3QgMTYuMytcbiAgLy8gQXJpdHkgKHByb3BzLCBzdGF0ZSlcbiAgc3RhdGljIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhfcmVmIC8qOjogKi8sIF9yZWYyIC8qOjogKi8pIC8qOiA/UGFydGlhbDxEcmFnZ2FibGVTdGF0ZT4qL3tcbiAgICBsZXQge1xuICAgICAgcG9zaXRpb25cbiAgICB9IC8qOiBEcmFnZ2FibGVQcm9wcyovID0gX3JlZiAvKjogRHJhZ2dhYmxlUHJvcHMqLztcbiAgICBsZXQge1xuICAgICAgcHJldlByb3BzUG9zaXRpb25cbiAgICB9IC8qOiBEcmFnZ2FibGVTdGF0ZSovID0gX3JlZjIgLyo6IERyYWdnYWJsZVN0YXRlKi87XG4gICAgLy8gU2V0IHgveSBpZiBhIG5ldyBwb3NpdGlvbiBpcyBwcm92aWRlZCBpbiBwcm9wcyB0aGF0IGlzIGRpZmZlcmVudCB0aGFuIHRoZSBwcmV2aW91cy5cbiAgICBpZiAocG9zaXRpb24gJiYgKCFwcmV2UHJvcHNQb3NpdGlvbiB8fCBwb3NpdGlvbi54ICE9PSBwcmV2UHJvcHNQb3NpdGlvbi54IHx8IHBvc2l0aW9uLnkgIT09IHByZXZQcm9wc1Bvc2l0aW9uLnkpKSB7XG4gICAgICAoMCwgX2xvZy5kZWZhdWx0KSgnRHJhZ2dhYmxlOiBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgJWonLCB7XG4gICAgICAgIHBvc2l0aW9uLFxuICAgICAgICBwcmV2UHJvcHNQb3NpdGlvblxuICAgICAgfSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiBwb3NpdGlvbi54LFxuICAgICAgICB5OiBwb3NpdGlvbi55LFxuICAgICAgICBwcmV2UHJvcHNQb3NpdGlvbjoge1xuICAgICAgICAgIC4uLnBvc2l0aW9uXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0cnVjdG9yKHByb3BzIC8qOiBEcmFnZ2FibGVQcm9wcyovKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm9uRHJhZ1N0YXJ0XCIsIChlLCBjb3JlRGF0YSkgPT4ge1xuICAgICAgKDAsIF9sb2cuZGVmYXVsdCkoJ0RyYWdnYWJsZTogb25EcmFnU3RhcnQ6ICVqJywgY29yZURhdGEpO1xuXG4gICAgICAvLyBTaG9ydC1jaXJjdWl0IGlmIHVzZXIncyBjYWxsYmFjayBraWxsZWQgaXQuXG4gICAgICBjb25zdCBzaG91bGRTdGFydCA9IHRoaXMucHJvcHMub25TdGFydChlLCAoMCwgX3Bvc2l0aW9uRm5zLmNyZWF0ZURyYWdnYWJsZURhdGEpKHRoaXMsIGNvcmVEYXRhKSk7XG4gICAgICAvLyBLaWxscyBzdGFydCBldmVudCBvbiBjb3JlIGFzIHdlbGwsIHNvIG1vdmUgaGFuZGxlcnMgYXJlIG5ldmVyIGJvdW5kLlxuICAgICAgaWYgKHNob3VsZFN0YXJ0ID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIGRyYWdnaW5nOiB0cnVlLFxuICAgICAgICBkcmFnZ2VkOiB0cnVlXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJvbkRyYWdcIiwgKGUsIGNvcmVEYXRhKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuc3RhdGUuZHJhZ2dpbmcpIHJldHVybiBmYWxzZTtcbiAgICAgICgwLCBfbG9nLmRlZmF1bHQpKCdEcmFnZ2FibGU6IG9uRHJhZzogJWonLCBjb3JlRGF0YSk7XG4gICAgICBjb25zdCB1aURhdGEgPSAoMCwgX3Bvc2l0aW9uRm5zLmNyZWF0ZURyYWdnYWJsZURhdGEpKHRoaXMsIGNvcmVEYXRhKTtcbiAgICAgIGNvbnN0IG5ld1N0YXRlID0ge1xuICAgICAgICB4OiB1aURhdGEueCxcbiAgICAgICAgeTogdWlEYXRhLnksXG4gICAgICAgIHNsYWNrWDogMCxcbiAgICAgICAgc2xhY2tZOiAwXG4gICAgICB9O1xuXG4gICAgICAvLyBLZWVwIHdpdGhpbiBib3VuZHMuXG4gICAgICBpZiAodGhpcy5wcm9wcy5ib3VuZHMpIHtcbiAgICAgICAgLy8gU2F2ZSBvcmlnaW5hbCB4IGFuZCB5LlxuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgeCxcbiAgICAgICAgICB5XG4gICAgICAgIH0gPSBuZXdTdGF0ZTtcblxuICAgICAgICAvLyBBZGQgc2xhY2sgdG8gdGhlIHZhbHVlcyB1c2VkIHRvIGNhbGN1bGF0ZSBib3VuZCBwb3NpdGlvbi4gVGhpcyB3aWxsIGVuc3VyZSB0aGF0IGlmXG4gICAgICAgIC8vIHdlIHN0YXJ0IHJlbW92aW5nIHNsYWNrLCB0aGUgZWxlbWVudCB3b24ndCByZWFjdCB0byBpdCByaWdodCBhd2F5IHVudGlsIGl0J3MgYmVlblxuICAgICAgICAvLyBjb21wbGV0ZWx5IHJlbW92ZWQuXG4gICAgICAgIG5ld1N0YXRlLnggKz0gdGhpcy5zdGF0ZS5zbGFja1g7XG4gICAgICAgIG5ld1N0YXRlLnkgKz0gdGhpcy5zdGF0ZS5zbGFja1k7XG5cbiAgICAgICAgLy8gR2V0IGJvdW5kIHBvc2l0aW9uLiBUaGlzIHdpbGwgY2VpbC9mbG9vciB0aGUgeCBhbmQgeSB3aXRoaW4gdGhlIGJvdW5kYXJpZXMuXG4gICAgICAgIGNvbnN0IFtuZXdTdGF0ZVgsIG5ld1N0YXRlWV0gPSAoMCwgX3Bvc2l0aW9uRm5zLmdldEJvdW5kUG9zaXRpb24pKHRoaXMsIG5ld1N0YXRlLngsIG5ld1N0YXRlLnkpO1xuICAgICAgICBuZXdTdGF0ZS54ID0gbmV3U3RhdGVYO1xuICAgICAgICBuZXdTdGF0ZS55ID0gbmV3U3RhdGVZO1xuXG4gICAgICAgIC8vIFJlY2FsY3VsYXRlIHNsYWNrIGJ5IG5vdGluZyBob3cgbXVjaCB3YXMgc2hhdmVkIGJ5IHRoZSBib3VuZFBvc2l0aW9uIGhhbmRsZXIuXG4gICAgICAgIG5ld1N0YXRlLnNsYWNrWCA9IHRoaXMuc3RhdGUuc2xhY2tYICsgKHggLSBuZXdTdGF0ZS54KTtcbiAgICAgICAgbmV3U3RhdGUuc2xhY2tZID0gdGhpcy5zdGF0ZS5zbGFja1kgKyAoeSAtIG5ld1N0YXRlLnkpO1xuXG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgZXZlbnQgd2UgZmlyZSB0byByZWZsZWN0IHdoYXQgcmVhbGx5IGhhcHBlbmVkIGFmdGVyIGJvdW5kcyB0b29rIGVmZmVjdC5cbiAgICAgICAgdWlEYXRhLnggPSBuZXdTdGF0ZS54O1xuICAgICAgICB1aURhdGEueSA9IG5ld1N0YXRlLnk7XG4gICAgICAgIHVpRGF0YS5kZWx0YVggPSBuZXdTdGF0ZS54IC0gdGhpcy5zdGF0ZS54O1xuICAgICAgICB1aURhdGEuZGVsdGFZID0gbmV3U3RhdGUueSAtIHRoaXMuc3RhdGUueTtcbiAgICAgIH1cblxuICAgICAgLy8gU2hvcnQtY2lyY3VpdCBpZiB1c2VyJ3MgY2FsbGJhY2sga2lsbGVkIGl0LlxuICAgICAgY29uc3Qgc2hvdWxkVXBkYXRlID0gdGhpcy5wcm9wcy5vbkRyYWcoZSwgdWlEYXRhKTtcbiAgICAgIGlmIChzaG91bGRVcGRhdGUgPT09IGZhbHNlKSByZXR1cm4gZmFsc2U7XG4gICAgICB0aGlzLnNldFN0YXRlKG5ld1N0YXRlKTtcbiAgICB9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJvbkRyYWdTdG9wXCIsIChlLCBjb3JlRGF0YSkgPT4ge1xuICAgICAgaWYgKCF0aGlzLnN0YXRlLmRyYWdnaW5nKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgIC8vIFNob3J0LWNpcmN1aXQgaWYgdXNlcidzIGNhbGxiYWNrIGtpbGxlZCBpdC5cbiAgICAgIGNvbnN0IHNob3VsZENvbnRpbnVlID0gdGhpcy5wcm9wcy5vblN0b3AoZSwgKDAsIF9wb3NpdGlvbkZucy5jcmVhdGVEcmFnZ2FibGVEYXRhKSh0aGlzLCBjb3JlRGF0YSkpO1xuICAgICAgaWYgKHNob3VsZENvbnRpbnVlID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgKDAsIF9sb2cuZGVmYXVsdCkoJ0RyYWdnYWJsZTogb25EcmFnU3RvcDogJWonLCBjb3JlRGF0YSk7XG4gICAgICBjb25zdCBuZXdTdGF0ZSAvKjogUGFydGlhbDxEcmFnZ2FibGVTdGF0ZT4qLyA9IHtcbiAgICAgICAgZHJhZ2dpbmc6IGZhbHNlLFxuICAgICAgICBzbGFja1g6IDAsXG4gICAgICAgIHNsYWNrWTogMFxuICAgICAgfTtcblxuICAgICAgLy8gSWYgdGhpcyBpcyBhIGNvbnRyb2xsZWQgY29tcG9uZW50LCB0aGUgcmVzdWx0IG9mIHRoaXMgb3BlcmF0aW9uIHdpbGwgYmUgdG9cbiAgICAgIC8vIHJldmVydCBiYWNrIHRvIHRoZSBvbGQgcG9zaXRpb24uIFdlIGV4cGVjdCBhIGhhbmRsZXIgb24gYG9uRHJhZ1N0b3BgLCBhdCB0aGUgbGVhc3QuXG4gICAgICBjb25zdCBjb250cm9sbGVkID0gQm9vbGVhbih0aGlzLnByb3BzLnBvc2l0aW9uKTtcbiAgICAgIGlmIChjb250cm9sbGVkKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICB4LFxuICAgICAgICAgIHlcbiAgICAgICAgfSA9IHRoaXMucHJvcHMucG9zaXRpb247XG4gICAgICAgIG5ld1N0YXRlLnggPSB4O1xuICAgICAgICBuZXdTdGF0ZS55ID0geTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0U3RhdGUobmV3U3RhdGUpO1xuICAgIH0pO1xuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAvLyBXaGV0aGVyIG9yIG5vdCB3ZSBhcmUgY3VycmVudGx5IGRyYWdnaW5nLlxuICAgICAgZHJhZ2dpbmc6IGZhbHNlLFxuICAgICAgLy8gV2hldGhlciBvciBub3Qgd2UgaGF2ZSBiZWVuIGRyYWdnZWQgYmVmb3JlLlxuICAgICAgZHJhZ2dlZDogZmFsc2UsXG4gICAgICAvLyBDdXJyZW50IHRyYW5zZm9ybSB4IGFuZCB5LlxuICAgICAgeDogcHJvcHMucG9zaXRpb24gPyBwcm9wcy5wb3NpdGlvbi54IDogcHJvcHMuZGVmYXVsdFBvc2l0aW9uLngsXG4gICAgICB5OiBwcm9wcy5wb3NpdGlvbiA/IHByb3BzLnBvc2l0aW9uLnkgOiBwcm9wcy5kZWZhdWx0UG9zaXRpb24ueSxcbiAgICAgIHByZXZQcm9wc1Bvc2l0aW9uOiB7XG4gICAgICAgIC4uLnByb3BzLnBvc2l0aW9uXG4gICAgICB9LFxuICAgICAgLy8gVXNlZCBmb3IgY29tcGVuc2F0aW5nIGZvciBvdXQtb2YtYm91bmRzIGRyYWdzXG4gICAgICBzbGFja1g6IDAsXG4gICAgICBzbGFja1k6IDAsXG4gICAgICAvLyBDYW4gb25seSBkZXRlcm1pbmUgaWYgU1ZHIGFmdGVyIG1vdW50aW5nXG4gICAgICBpc0VsZW1lbnRTVkc6IGZhbHNlXG4gICAgfTtcbiAgICBpZiAocHJvcHMucG9zaXRpb24gJiYgIShwcm9wcy5vbkRyYWcgfHwgcHJvcHMub25TdG9wKSkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIGNvbnNvbGUud2FybignQSBgcG9zaXRpb25gIHdhcyBhcHBsaWVkIHRvIHRoaXMgPERyYWdnYWJsZT4sIHdpdGhvdXQgZHJhZyBoYW5kbGVycy4gVGhpcyB3aWxsIG1ha2UgdGhpcyAnICsgJ2NvbXBvbmVudCBlZmZlY3RpdmVseSB1bmRyYWdnYWJsZS4gUGxlYXNlIGF0dGFjaCBgb25EcmFnYCBvciBgb25TdG9wYCBoYW5kbGVycyBzbyB5b3UgY2FuIGFkanVzdCB0aGUgJyArICdgcG9zaXRpb25gIG9mIHRoaXMgZWxlbWVudC4nKTtcbiAgICB9XG4gIH1cbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgLy8gQ2hlY2sgdG8gc2VlIGlmIHRoZSBlbGVtZW50IHBhc3NlZCBpcyBhbiBpbnN0YW5jZW9mIFNWR0VsZW1lbnRcbiAgICBpZiAodHlwZW9mIHdpbmRvdy5TVkdFbGVtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB0aGlzLmZpbmRET01Ob2RlKCkgaW5zdGFuY2VvZiB3aW5kb3cuU1ZHRWxlbWVudCkge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIGlzRWxlbWVudFNWRzogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIGlmICh0aGlzLnN0YXRlLmRyYWdnaW5nKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgZHJhZ2dpbmc6IGZhbHNlXG4gICAgICB9KTsgLy8gcHJldmVudHMgaW52YXJpYW50IGlmIHVubW91bnRlZCB3aGlsZSBkcmFnZ2luZ1xuICAgIH1cbiAgfVxuXG4gIC8vIFJlYWN0IFN0cmljdCBNb2RlIGNvbXBhdGliaWxpdHk6IGlmIGBub2RlUmVmYCBpcyBwYXNzZWQsIHdlIHdpbGwgdXNlIGl0IGluc3RlYWQgb2YgdHJ5aW5nIHRvIGZpbmRcbiAgLy8gdGhlIHVuZGVybHlpbmcgRE9NIG5vZGUgb3Vyc2VsdmVzLiBTZWUgdGhlIFJFQURNRSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgZmluZERPTU5vZGUoKSAvKjogP0hUTUxFbGVtZW50Ki97XG4gICAgcmV0dXJuIHRoaXMucHJvcHM/Lm5vZGVSZWY/LmN1cnJlbnQgPz8gX3JlYWN0RG9tLmRlZmF1bHQuZmluZERPTU5vZGUodGhpcyk7XG4gIH1cbiAgcmVuZGVyKCkgLyo6IFJlYWN0RWxlbWVudDxhbnk+Ki97XG4gICAgY29uc3Qge1xuICAgICAgYXhpcyxcbiAgICAgIGJvdW5kcyxcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgZGVmYXVsdFBvc2l0aW9uLFxuICAgICAgZGVmYXVsdENsYXNzTmFtZSxcbiAgICAgIGRlZmF1bHRDbGFzc05hbWVEcmFnZ2luZyxcbiAgICAgIGRlZmF1bHRDbGFzc05hbWVEcmFnZ2VkLFxuICAgICAgcG9zaXRpb24sXG4gICAgICBwb3NpdGlvbk9mZnNldCxcbiAgICAgIHNjYWxlLFxuICAgICAgLi4uZHJhZ2dhYmxlQ29yZVByb3BzXG4gICAgfSA9IHRoaXMucHJvcHM7XG4gICAgbGV0IHN0eWxlID0ge307XG4gICAgbGV0IHN2Z1RyYW5zZm9ybSA9IG51bGw7XG5cbiAgICAvLyBJZiB0aGlzIGlzIGNvbnRyb2xsZWQsIHdlIGRvbid0IHdhbnQgdG8gbW92ZSBpdCAtIHVubGVzcyBpdCdzIGRyYWdnaW5nLlxuICAgIGNvbnN0IGNvbnRyb2xsZWQgPSBCb29sZWFuKHBvc2l0aW9uKTtcbiAgICBjb25zdCBkcmFnZ2FibGUgPSAhY29udHJvbGxlZCB8fCB0aGlzLnN0YXRlLmRyYWdnaW5nO1xuICAgIGNvbnN0IHZhbGlkUG9zaXRpb24gPSBwb3NpdGlvbiB8fCBkZWZhdWx0UG9zaXRpb247XG4gICAgY29uc3QgdHJhbnNmb3JtT3B0cyA9IHtcbiAgICAgIC8vIFNldCBsZWZ0IGlmIGhvcml6b250YWwgZHJhZyBpcyBlbmFibGVkXG4gICAgICB4OiAoMCwgX3Bvc2l0aW9uRm5zLmNhbkRyYWdYKSh0aGlzKSAmJiBkcmFnZ2FibGUgPyB0aGlzLnN0YXRlLnggOiB2YWxpZFBvc2l0aW9uLngsXG4gICAgICAvLyBTZXQgdG9wIGlmIHZlcnRpY2FsIGRyYWcgaXMgZW5hYmxlZFxuICAgICAgeTogKDAsIF9wb3NpdGlvbkZucy5jYW5EcmFnWSkodGhpcykgJiYgZHJhZ2dhYmxlID8gdGhpcy5zdGF0ZS55IDogdmFsaWRQb3NpdGlvbi55XG4gICAgfTtcblxuICAgIC8vIElmIHRoaXMgZWxlbWVudCB3YXMgU1ZHLCB3ZSB1c2UgdGhlIGB0cmFuc2Zvcm1gIGF0dHJpYnV0ZS5cbiAgICBpZiAodGhpcy5zdGF0ZS5pc0VsZW1lbnRTVkcpIHtcbiAgICAgIHN2Z1RyYW5zZm9ybSA9ICgwLCBfZG9tRm5zLmNyZWF0ZVNWR1RyYW5zZm9ybSkodHJhbnNmb3JtT3B0cywgcG9zaXRpb25PZmZzZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBBZGQgYSBDU1MgdHJhbnNmb3JtIHRvIG1vdmUgdGhlIGVsZW1lbnQgYXJvdW5kLiBUaGlzIGFsbG93cyB1cyB0byBtb3ZlIHRoZSBlbGVtZW50IGFyb3VuZFxuICAgICAgLy8gd2l0aG91dCB3b3JyeWluZyBhYm91dCB3aGV0aGVyIG9yIG5vdCBpdCBpcyByZWxhdGl2ZWx5IG9yIGFic29sdXRlbHkgcG9zaXRpb25lZC5cbiAgICAgIC8vIElmIHRoZSBpdGVtIHlvdSBhcmUgZHJhZ2dpbmcgYWxyZWFkeSBoYXMgYSB0cmFuc2Zvcm0gc2V0LCB3cmFwIGl0IGluIGEgPHNwYW4+IHNvIDxEcmFnZ2FibGU+XG4gICAgICAvLyBoYXMgYSBjbGVhbiBzbGF0ZS5cbiAgICAgIHN0eWxlID0gKDAsIF9kb21GbnMuY3JlYXRlQ1NTVHJhbnNmb3JtKSh0cmFuc2Zvcm1PcHRzLCBwb3NpdGlvbk9mZnNldCk7XG4gICAgfVxuXG4gICAgLy8gTWFyayB3aXRoIGNsYXNzIHdoaWxlIGRyYWdnaW5nXG4gICAgY29uc3QgY2xhc3NOYW1lID0gKDAsIF9jbHN4LmNsc3gpKGNoaWxkcmVuLnByb3BzLmNsYXNzTmFtZSB8fCAnJywgZGVmYXVsdENsYXNzTmFtZSwge1xuICAgICAgW2RlZmF1bHRDbGFzc05hbWVEcmFnZ2luZ106IHRoaXMuc3RhdGUuZHJhZ2dpbmcsXG4gICAgICBbZGVmYXVsdENsYXNzTmFtZURyYWdnZWRdOiB0aGlzLnN0YXRlLmRyYWdnZWRcbiAgICB9KTtcblxuICAgIC8vIFJldXNlIHRoZSBjaGlsZCBwcm92aWRlZFxuICAgIC8vIFRoaXMgbWFrZXMgaXQgZmxleGlibGUgdG8gdXNlIHdoYXRldmVyIGVsZW1lbnQgaXMgd2FudGVkIChkaXYsIHVsLCBldGMpXG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KF9EcmFnZ2FibGVDb3JlLmRlZmF1bHQsIF9leHRlbmRzKHt9LCBkcmFnZ2FibGVDb3JlUHJvcHMsIHtcbiAgICAgIG9uU3RhcnQ6IHRoaXMub25EcmFnU3RhcnQsXG4gICAgICBvbkRyYWc6IHRoaXMub25EcmFnLFxuICAgICAgb25TdG9wOiB0aGlzLm9uRHJhZ1N0b3BcbiAgICB9KSwgLyojX19QVVJFX18qL1JlYWN0LmNsb25lRWxlbWVudChSZWFjdC5DaGlsZHJlbi5vbmx5KGNoaWxkcmVuKSwge1xuICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWUsXG4gICAgICBzdHlsZToge1xuICAgICAgICAuLi5jaGlsZHJlbi5wcm9wcy5zdHlsZSxcbiAgICAgICAgLi4uc3R5bGVcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm06IHN2Z1RyYW5zZm9ybVxuICAgIH0pKTtcbiAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gRHJhZ2dhYmxlO1xuX2RlZmluZVByb3BlcnR5KERyYWdnYWJsZSwgXCJkaXNwbGF5TmFtZVwiLCAnRHJhZ2dhYmxlJyk7XG5fZGVmaW5lUHJvcGVydHkoRHJhZ2dhYmxlLCBcInByb3BUeXBlc1wiLCB7XG4gIC8vIEFjY2VwdHMgYWxsIHByb3BzIDxEcmFnZ2FibGVDb3JlPiBhY2NlcHRzLlxuICAuLi5fRHJhZ2dhYmxlQ29yZS5kZWZhdWx0LnByb3BUeXBlcyxcbiAgLyoqXG4gICAqIGBheGlzYCBkZXRlcm1pbmVzIHdoaWNoIGF4aXMgdGhlIGRyYWdnYWJsZSBjYW4gbW92ZS5cbiAgICpcbiAgICogIE5vdGUgdGhhdCBhbGwgY2FsbGJhY2tzIHdpbGwgc3RpbGwgcmV0dXJuIGRhdGEgYXMgbm9ybWFsLiBUaGlzIG9ubHlcbiAgICogIGNvbnRyb2xzIGZsdXNoaW5nIHRvIHRoZSBET00uXG4gICAqXG4gICAqICdib3RoJyBhbGxvd3MgbW92ZW1lbnQgaG9yaXpvbnRhbGx5IGFuZCB2ZXJ0aWNhbGx5LlxuICAgKiAneCcgbGltaXRzIG1vdmVtZW50IHRvIGhvcml6b250YWwgYXhpcy5cbiAgICogJ3knIGxpbWl0cyBtb3ZlbWVudCB0byB2ZXJ0aWNhbCBheGlzLlxuICAgKiAnbm9uZScgbGltaXRzIGFsbCBtb3ZlbWVudC5cbiAgICpcbiAgICogRGVmYXVsdHMgdG8gJ2JvdGgnLlxuICAgKi9cbiAgYXhpczogX3Byb3BUeXBlcy5kZWZhdWx0Lm9uZU9mKFsnYm90aCcsICd4JywgJ3knLCAnbm9uZSddKSxcbiAgLyoqXG4gICAqIGBib3VuZHNgIGRldGVybWluZXMgdGhlIHJhbmdlIG9mIG1vdmVtZW50IGF2YWlsYWJsZSB0byB0aGUgZWxlbWVudC5cbiAgICogQXZhaWxhYmxlIHZhbHVlcyBhcmU6XG4gICAqXG4gICAqICdwYXJlbnQnIHJlc3RyaWN0cyBtb3ZlbWVudCB3aXRoaW4gdGhlIERyYWdnYWJsZSdzIHBhcmVudCBub2RlLlxuICAgKlxuICAgKiBBbHRlcm5hdGl2ZWx5LCBwYXNzIGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllcywgYWxsIG9mIHdoaWNoIGFyZSBvcHRpb25hbDpcbiAgICpcbiAgICoge2xlZnQ6IExFRlRfQk9VTkQsIHJpZ2h0OiBSSUdIVF9CT1VORCwgYm90dG9tOiBCT1RUT01fQk9VTkQsIHRvcDogVE9QX0JPVU5EfVxuICAgKlxuICAgKiBBbGwgdmFsdWVzIGFyZSBpbiBweC5cbiAgICpcbiAgICogRXhhbXBsZTpcbiAgICpcbiAgICogYGBganN4XG4gICAqICAgbGV0IEFwcCA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgICogICAgICAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAqICAgICAgICAgcmV0dXJuIChcbiAgICogICAgICAgICAgICA8RHJhZ2dhYmxlIGJvdW5kcz17e3JpZ2h0OiAzMDAsIGJvdHRvbTogMzAwfX0+XG4gICAqICAgICAgICAgICAgICA8ZGl2PkNvbnRlbnQ8L2Rpdj5cbiAgICogICAgICAgICAgIDwvRHJhZ2dhYmxlPlxuICAgKiAgICAgICAgICk7XG4gICAqICAgICAgIH1cbiAgICogICB9KTtcbiAgICogYGBgXG4gICAqL1xuICBib3VuZHM6IF9wcm9wVHlwZXMuZGVmYXVsdC5vbmVPZlR5cGUoW19wcm9wVHlwZXMuZGVmYXVsdC5zaGFwZSh7XG4gICAgbGVmdDogX3Byb3BUeXBlcy5kZWZhdWx0Lm51bWJlcixcbiAgICByaWdodDogX3Byb3BUeXBlcy5kZWZhdWx0Lm51bWJlcixcbiAgICB0b3A6IF9wcm9wVHlwZXMuZGVmYXVsdC5udW1iZXIsXG4gICAgYm90dG9tOiBfcHJvcFR5cGVzLmRlZmF1bHQubnVtYmVyXG4gIH0pLCBfcHJvcFR5cGVzLmRlZmF1bHQuc3RyaW5nLCBfcHJvcFR5cGVzLmRlZmF1bHQub25lT2YoW2ZhbHNlXSldKSxcbiAgZGVmYXVsdENsYXNzTmFtZTogX3Byb3BUeXBlcy5kZWZhdWx0LnN0cmluZyxcbiAgZGVmYXVsdENsYXNzTmFtZURyYWdnaW5nOiBfcHJvcFR5cGVzLmRlZmF1bHQuc3RyaW5nLFxuICBkZWZhdWx0Q2xhc3NOYW1lRHJhZ2dlZDogX3Byb3BUeXBlcy5kZWZhdWx0LnN0cmluZyxcbiAgLyoqXG4gICAqIGBkZWZhdWx0UG9zaXRpb25gIHNwZWNpZmllcyB0aGUgeCBhbmQgeSB0aGF0IHRoZSBkcmFnZ2VkIGl0ZW0gc2hvdWxkIHN0YXJ0IGF0XG4gICAqXG4gICAqIEV4YW1wbGU6XG4gICAqXG4gICAqIGBgYGpzeFxuICAgKiAgICAgIGxldCBBcHAgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gICAqICAgICAgICAgIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICAgKiAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICogICAgICAgICAgICAgICAgICA8RHJhZ2dhYmxlIGRlZmF1bHRQb3NpdGlvbj17e3g6IDI1LCB5OiAyNX19PlxuICAgKiAgICAgICAgICAgICAgICAgICAgICA8ZGl2Pkkgc3RhcnQgd2l0aCB0cmFuc2Zvcm1YOiAyNXB4IGFuZCB0cmFuc2Zvcm1ZOiAyNXB4OzwvZGl2PlxuICAgKiAgICAgICAgICAgICAgICAgIDwvRHJhZ2dhYmxlPlxuICAgKiAgICAgICAgICAgICAgKTtcbiAgICogICAgICAgICAgfVxuICAgKiAgICAgIH0pO1xuICAgKiBgYGBcbiAgICovXG4gIGRlZmF1bHRQb3NpdGlvbjogX3Byb3BUeXBlcy5kZWZhdWx0LnNoYXBlKHtcbiAgICB4OiBfcHJvcFR5cGVzLmRlZmF1bHQubnVtYmVyLFxuICAgIHk6IF9wcm9wVHlwZXMuZGVmYXVsdC5udW1iZXJcbiAgfSksXG4gIHBvc2l0aW9uT2Zmc2V0OiBfcHJvcFR5cGVzLmRlZmF1bHQuc2hhcGUoe1xuICAgIHg6IF9wcm9wVHlwZXMuZGVmYXVsdC5vbmVPZlR5cGUoW19wcm9wVHlwZXMuZGVmYXVsdC5udW1iZXIsIF9wcm9wVHlwZXMuZGVmYXVsdC5zdHJpbmddKSxcbiAgICB5OiBfcHJvcFR5cGVzLmRlZmF1bHQub25lT2ZUeXBlKFtfcHJvcFR5cGVzLmRlZmF1bHQubnVtYmVyLCBfcHJvcFR5cGVzLmRlZmF1bHQuc3RyaW5nXSlcbiAgfSksXG4gIC8qKlxuICAgKiBgcG9zaXRpb25gLCBpZiBwcmVzZW50LCBkZWZpbmVzIHRoZSBjdXJyZW50IHBvc2l0aW9uIG9mIHRoZSBlbGVtZW50LlxuICAgKlxuICAgKiAgVGhpcyBpcyBzaW1pbGFyIHRvIGhvdyBmb3JtIGVsZW1lbnRzIGluIFJlYWN0IHdvcmsgLSBpZiBubyBgcG9zaXRpb25gIGlzIHN1cHBsaWVkLCB0aGUgY29tcG9uZW50XG4gICAqICBpcyB1bmNvbnRyb2xsZWQuXG4gICAqXG4gICAqIEV4YW1wbGU6XG4gICAqXG4gICAqIGBgYGpzeFxuICAgKiAgICAgIGxldCBBcHAgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gICAqICAgICAgICAgIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICAgKiAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICogICAgICAgICAgICAgICAgICA8RHJhZ2dhYmxlIHBvc2l0aW9uPXt7eDogMjUsIHk6IDI1fX0+XG4gICAqICAgICAgICAgICAgICAgICAgICAgIDxkaXY+SSBzdGFydCB3aXRoIHRyYW5zZm9ybVg6IDI1cHggYW5kIHRyYW5zZm9ybVk6IDI1cHg7PC9kaXY+XG4gICAqICAgICAgICAgICAgICAgICAgPC9EcmFnZ2FibGU+XG4gICAqICAgICAgICAgICAgICApO1xuICAgKiAgICAgICAgICB9XG4gICAqICAgICAgfSk7XG4gICAqIGBgYFxuICAgKi9cbiAgcG9zaXRpb246IF9wcm9wVHlwZXMuZGVmYXVsdC5zaGFwZSh7XG4gICAgeDogX3Byb3BUeXBlcy5kZWZhdWx0Lm51bWJlcixcbiAgICB5OiBfcHJvcFR5cGVzLmRlZmF1bHQubnVtYmVyXG4gIH0pLFxuICAvKipcbiAgICogVGhlc2UgcHJvcGVydGllcyBzaG91bGQgYmUgZGVmaW5lZCBvbiB0aGUgY2hpbGQsIG5vdCBoZXJlLlxuICAgKi9cbiAgY2xhc3NOYW1lOiBfc2hpbXMuZG9udFNldE1lLFxuICBzdHlsZTogX3NoaW1zLmRvbnRTZXRNZSxcbiAgdHJhbnNmb3JtOiBfc2hpbXMuZG9udFNldE1lXG59KTtcbl9kZWZpbmVQcm9wZXJ0eShEcmFnZ2FibGUsIFwiZGVmYXVsdFByb3BzXCIsIHtcbiAgLi4uX0RyYWdnYWJsZUNvcmUuZGVmYXVsdC5kZWZhdWx0UHJvcHMsXG4gIGF4aXM6ICdib3RoJyxcbiAgYm91bmRzOiBmYWxzZSxcbiAgZGVmYXVsdENsYXNzTmFtZTogJ3JlYWN0LWRyYWdnYWJsZScsXG4gIGRlZmF1bHRDbGFzc05hbWVEcmFnZ2luZzogJ3JlYWN0LWRyYWdnYWJsZS1kcmFnZ2luZycsXG4gIGRlZmF1bHRDbGFzc05hbWVEcmFnZ2VkOiAncmVhY3QtZHJhZ2dhYmxlLWRyYWdnZWQnLFxuICBkZWZhdWx0UG9zaXRpb246IHtcbiAgICB4OiAwLFxuICAgIHk6IDBcbiAgfSxcbiAgc2NhbGU6IDFcbn0pOyJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJnZXQiLCJfRHJhZ2dhYmxlQ29yZSIsImRlZmF1bHQiLCJSZWFjdCIsIl9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkIiwicmVxdWlyZSIsIl9wcm9wVHlwZXMiLCJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0IiwiX3JlYWN0RG9tIiwiX2Nsc3giLCJfZG9tRm5zIiwiX3Bvc2l0aW9uRm5zIiwiX3NoaW1zIiwiX2xvZyIsImUiLCJfX2VzTW9kdWxlIiwidCIsIldlYWtNYXAiLCJyIiwibiIsIm8iLCJpIiwiZiIsIl9fcHJvdG9fXyIsImhhcyIsInNldCIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIl9leHRlbmRzIiwiYXNzaWduIiwiYmluZCIsImFyZ3VtZW50cyIsImxlbmd0aCIsImFwcGx5IiwiX2RlZmluZVByb3BlcnR5IiwiX3RvUHJvcGVydHlLZXkiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIl90b1ByaW1pdGl2ZSIsIlN5bWJvbCIsInRvUHJpbWl0aXZlIiwiVHlwZUVycm9yIiwiU3RyaW5nIiwiTnVtYmVyIiwiRHJhZ2dhYmxlIiwiQ29tcG9uZW50IiwiZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzIiwiX3JlZiIsIl9yZWYyIiwicG9zaXRpb24iLCJwcmV2UHJvcHNQb3NpdGlvbiIsIngiLCJ5IiwiY29uc3RydWN0b3IiLCJwcm9wcyIsImNvcmVEYXRhIiwic2hvdWxkU3RhcnQiLCJvblN0YXJ0IiwiY3JlYXRlRHJhZ2dhYmxlRGF0YSIsInNldFN0YXRlIiwiZHJhZ2dpbmciLCJkcmFnZ2VkIiwic3RhdGUiLCJ1aURhdGEiLCJuZXdTdGF0ZSIsInNsYWNrWCIsInNsYWNrWSIsImJvdW5kcyIsIm5ld1N0YXRlWCIsIm5ld1N0YXRlWSIsImdldEJvdW5kUG9zaXRpb24iLCJkZWx0YVgiLCJkZWx0YVkiLCJzaG91bGRVcGRhdGUiLCJvbkRyYWciLCJzaG91bGRDb250aW51ZSIsIm9uU3RvcCIsImNvbnRyb2xsZWQiLCJCb29sZWFuIiwiZGVmYXVsdFBvc2l0aW9uIiwiaXNFbGVtZW50U1ZHIiwiY29uc29sZSIsIndhcm4iLCJjb21wb25lbnREaWRNb3VudCIsIndpbmRvdyIsIlNWR0VsZW1lbnQiLCJmaW5kRE9NTm9kZSIsImNvbXBvbmVudFdpbGxVbm1vdW50Iiwibm9kZVJlZiIsImN1cnJlbnQiLCJyZW5kZXIiLCJheGlzIiwiY2hpbGRyZW4iLCJkZWZhdWx0Q2xhc3NOYW1lIiwiZGVmYXVsdENsYXNzTmFtZURyYWdnaW5nIiwiZGVmYXVsdENsYXNzTmFtZURyYWdnZWQiLCJwb3NpdGlvbk9mZnNldCIsInNjYWxlIiwiZHJhZ2dhYmxlQ29yZVByb3BzIiwic3R5bGUiLCJzdmdUcmFuc2Zvcm0iLCJkcmFnZ2FibGUiLCJ2YWxpZFBvc2l0aW9uIiwidHJhbnNmb3JtT3B0cyIsImNhbkRyYWdYIiwiY2FuRHJhZ1kiLCJjcmVhdGVTVkdUcmFuc2Zvcm0iLCJjcmVhdGVDU1NUcmFuc2Zvcm0iLCJjbGFzc05hbWUiLCJjbHN4IiwiY3JlYXRlRWxlbWVudCIsIm9uRHJhZ1N0YXJ0Iiwib25EcmFnU3RvcCIsImNsb25lRWxlbWVudCIsIkNoaWxkcmVuIiwib25seSIsInRyYW5zZm9ybSIsInByb3BUeXBlcyIsIm9uZU9mIiwib25lT2ZUeXBlIiwic2hhcGUiLCJsZWZ0IiwibnVtYmVyIiwicmlnaHQiLCJ0b3AiLCJib3R0b20iLCJzdHJpbmciLCJkb250U2V0TWUiLCJkZWZhdWx0UHJvcHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-draggable/build/cjs/Draggable.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-draggable/build/cjs/DraggableCore.js":
/*!*****************************************************************!*\
  !*** ./node_modules/react-draggable/build/cjs/DraggableCore.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports[\"default\"] = void 0;\nvar React = _interopRequireWildcard(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"));\nvar _propTypes = _interopRequireDefault(__webpack_require__(/*! prop-types */ \"(ssr)/./node_modules/prop-types/index.js\"));\nvar _reactDom = _interopRequireDefault(__webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\"));\nvar _domFns = __webpack_require__(/*! ./utils/domFns */ \"(ssr)/./node_modules/react-draggable/build/cjs/utils/domFns.js\");\nvar _positionFns = __webpack_require__(/*! ./utils/positionFns */ \"(ssr)/./node_modules/react-draggable/build/cjs/utils/positionFns.js\");\nvar _shims = __webpack_require__(/*! ./utils/shims */ \"(ssr)/./node_modules/react-draggable/build/cjs/utils/shims.js\");\nvar _log = _interopRequireDefault(__webpack_require__(/*! ./utils/log */ \"(ssr)/./node_modules/react-draggable/build/cjs/utils/log.js\"));\nfunction _interopRequireDefault(e) {\n    return e && e.__esModule ? e : {\n        default: e\n    };\n}\nfunction _interopRequireWildcard(e, t) {\n    if (\"function\" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap();\n    return (_interopRequireWildcard = function(e, t) {\n        if (!t && e && e.__esModule) return e;\n        var o, i, f = {\n            __proto__: null,\n            default: e\n        };\n        if (null === e || \"object\" != typeof e && \"function\" != typeof e) return f;\n        if (o = t ? n : r) {\n            if (o.has(e)) return o.get(e);\n            o.set(e, f);\n        }\n        for(const t in e)\"default\" !== t && ({}).hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]);\n        return f;\n    })(e, t);\n}\nfunction _defineProperty(e, r, t) {\n    return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n        value: t,\n        enumerable: !0,\n        configurable: !0,\n        writable: !0\n    }) : e[r] = t, e;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == typeof i ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != typeof t || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != typeof i) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\n/*:: import type {EventHandler, MouseTouchEvent} from './utils/types';*/ /*:: import type {Element as ReactElement} from 'react';*/ // Simple abstraction for dragging events names.\nconst eventsFor = {\n    touch: {\n        start: \"touchstart\",\n        move: \"touchmove\",\n        stop: \"touchend\"\n    },\n    mouse: {\n        start: \"mousedown\",\n        move: \"mousemove\",\n        stop: \"mouseup\"\n    }\n};\n// Default to mouse events.\nlet dragEventFor = eventsFor.mouse;\n/*:: export type DraggableData = {\n  node: HTMLElement,\n  x: number, y: number,\n  deltaX: number, deltaY: number,\n  lastX: number, lastY: number,\n};*/ /*:: export type DraggableEventHandler = (e: MouseEvent, data: DraggableData) => void | false;*/ /*:: export type ControlPosition = {x: number, y: number};*/ /*:: export type PositionOffsetControlPosition = {x: number|string, y: number|string};*/ /*:: export type DraggableCoreDefaultProps = {\n  allowAnyClick: boolean,\n  allowMobileScroll: boolean,\n  disabled: boolean,\n  enableUserSelectHack: boolean,\n  onStart: DraggableEventHandler,\n  onDrag: DraggableEventHandler,\n  onStop: DraggableEventHandler,\n  onMouseDown: (e: MouseEvent) => void,\n  scale: number,\n};*/ /*:: export type DraggableCoreProps = {\n  ...DraggableCoreDefaultProps,\n  cancel: string,\n  children: ReactElement<any>,\n  offsetParent: HTMLElement,\n  grid: [number, number],\n  handle: string,\n  nodeRef?: ?React.ElementRef<any>,\n};*/ //\n// Define <DraggableCore>.\n//\n// <DraggableCore> is for advanced usage of <Draggable>. It maintains minimal internal state so it can\n// work well with libraries that require more control over the element.\n//\nclass DraggableCore extends React.Component /*:: <DraggableCoreProps>*/  {\n    constructor(){\n        super(...arguments);\n        _defineProperty(this, \"dragging\", false);\n        // Used while dragging to determine deltas.\n        _defineProperty(this, \"lastX\", NaN);\n        _defineProperty(this, \"lastY\", NaN);\n        _defineProperty(this, \"touchIdentifier\", null);\n        _defineProperty(this, \"mounted\", false);\n        _defineProperty(this, \"handleDragStart\", (e)=>{\n            // Make it possible to attach event handlers on top of this one.\n            this.props.onMouseDown(e);\n            // Only accept left-clicks.\n            if (!this.props.allowAnyClick && typeof e.button === \"number\" && e.button !== 0) return false;\n            // Get nodes. Be sure to grab relative document (could be iframed)\n            const thisNode = this.findDOMNode();\n            if (!thisNode || !thisNode.ownerDocument || !thisNode.ownerDocument.body) {\n                throw new Error(\"<DraggableCore> not mounted on DragStart!\");\n            }\n            const { ownerDocument } = thisNode;\n            // Short circuit if handle or cancel prop was provided and selector doesn't match.\n            if (this.props.disabled || !(e.target instanceof ownerDocument.defaultView.Node) || this.props.handle && !(0, _domFns.matchesSelectorAndParentsTo)(e.target, this.props.handle, thisNode) || this.props.cancel && (0, _domFns.matchesSelectorAndParentsTo)(e.target, this.props.cancel, thisNode)) {\n                return;\n            }\n            // Prevent scrolling on mobile devices, like ipad/iphone.\n            // Important that this is after handle/cancel.\n            if (e.type === \"touchstart\" && !this.props.allowMobileScroll) e.preventDefault();\n            // Set touch identifier in component state if this is a touch event. This allows us to\n            // distinguish between individual touches on multitouch screens by identifying which\n            // touchpoint was set to this element.\n            const touchIdentifier = (0, _domFns.getTouchIdentifier)(e);\n            this.touchIdentifier = touchIdentifier;\n            // Get the current drag point from the event. This is used as the offset.\n            const position = (0, _positionFns.getControlPosition)(e, touchIdentifier, this);\n            if (position == null) return; // not possible but satisfies flow\n            const { x, y } = position;\n            // Create an event object with all the data parents need to make a decision here.\n            const coreEvent = (0, _positionFns.createCoreData)(this, x, y);\n            (0, _log.default)(\"DraggableCore: handleDragStart: %j\", coreEvent);\n            // Call event handler. If it returns explicit false, cancel.\n            (0, _log.default)(\"calling\", this.props.onStart);\n            const shouldUpdate = this.props.onStart(e, coreEvent);\n            if (shouldUpdate === false || this.mounted === false) return;\n            // Add a style to the body to disable user-select. This prevents text from\n            // being selected all over the page.\n            if (this.props.enableUserSelectHack) (0, _domFns.addUserSelectStyles)(ownerDocument);\n            // Initiate dragging. Set the current x and y as offsets\n            // so we know how much we've moved during the drag. This allows us\n            // to drag elements around even if they have been moved, without issue.\n            this.dragging = true;\n            this.lastX = x;\n            this.lastY = y;\n            // Add events to the document directly so we catch when the user's mouse/touch moves outside of\n            // this element. We use different events depending on whether or not we have detected that this\n            // is a touch-capable device.\n            (0, _domFns.addEvent)(ownerDocument, dragEventFor.move, this.handleDrag);\n            (0, _domFns.addEvent)(ownerDocument, dragEventFor.stop, this.handleDragStop);\n        });\n        _defineProperty(this, \"handleDrag\", (e)=>{\n            // Get the current drag point from the event. This is used as the offset.\n            const position = (0, _positionFns.getControlPosition)(e, this.touchIdentifier, this);\n            if (position == null) return;\n            let { x, y } = position;\n            // Snap to grid if prop has been provided\n            if (Array.isArray(this.props.grid)) {\n                let deltaX = x - this.lastX, deltaY = y - this.lastY;\n                [deltaX, deltaY] = (0, _positionFns.snapToGrid)(this.props.grid, deltaX, deltaY);\n                if (!deltaX && !deltaY) return; // skip useless drag\n                x = this.lastX + deltaX, y = this.lastY + deltaY;\n            }\n            const coreEvent = (0, _positionFns.createCoreData)(this, x, y);\n            (0, _log.default)(\"DraggableCore: handleDrag: %j\", coreEvent);\n            // Call event handler. If it returns explicit false, trigger end.\n            const shouldUpdate = this.props.onDrag(e, coreEvent);\n            if (shouldUpdate === false || this.mounted === false) {\n                try {\n                    // $FlowIgnore\n                    this.handleDragStop(new MouseEvent(\"mouseup\"));\n                } catch (err) {\n                    // Old browsers\n                    const event = document.createEvent(\"MouseEvents\");\n                    // I see why this insanity was deprecated\n                    // $FlowIgnore\n                    event.initMouseEvent(\"mouseup\", true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);\n                    this.handleDragStop(event);\n                }\n                return;\n            }\n            this.lastX = x;\n            this.lastY = y;\n        });\n        _defineProperty(this, \"handleDragStop\", (e)=>{\n            if (!this.dragging) return;\n            const position = (0, _positionFns.getControlPosition)(e, this.touchIdentifier, this);\n            if (position == null) return;\n            let { x, y } = position;\n            // Snap to grid if prop has been provided\n            if (Array.isArray(this.props.grid)) {\n                let deltaX = x - this.lastX || 0;\n                let deltaY = y - this.lastY || 0;\n                [deltaX, deltaY] = (0, _positionFns.snapToGrid)(this.props.grid, deltaX, deltaY);\n                x = this.lastX + deltaX, y = this.lastY + deltaY;\n            }\n            const coreEvent = (0, _positionFns.createCoreData)(this, x, y);\n            // Call event handler\n            const shouldContinue = this.props.onStop(e, coreEvent);\n            if (shouldContinue === false || this.mounted === false) return false;\n            const thisNode = this.findDOMNode();\n            if (thisNode) {\n                // Remove user-select hack\n                if (this.props.enableUserSelectHack) (0, _domFns.scheduleRemoveUserSelectStyles)(thisNode.ownerDocument);\n            }\n            (0, _log.default)(\"DraggableCore: handleDragStop: %j\", coreEvent);\n            // Reset the el.\n            this.dragging = false;\n            this.lastX = NaN;\n            this.lastY = NaN;\n            if (thisNode) {\n                // Remove event handlers\n                (0, _log.default)(\"DraggableCore: Removing handlers\");\n                (0, _domFns.removeEvent)(thisNode.ownerDocument, dragEventFor.move, this.handleDrag);\n                (0, _domFns.removeEvent)(thisNode.ownerDocument, dragEventFor.stop, this.handleDragStop);\n            }\n        });\n        _defineProperty(this, \"onMouseDown\", (e)=>{\n            dragEventFor = eventsFor.mouse; // on touchscreen laptops we could switch back to mouse\n            return this.handleDragStart(e);\n        });\n        _defineProperty(this, \"onMouseUp\", (e)=>{\n            dragEventFor = eventsFor.mouse;\n            return this.handleDragStop(e);\n        });\n        // Same as onMouseDown (start drag), but now consider this a touch device.\n        _defineProperty(this, \"onTouchStart\", (e)=>{\n            // We're on a touch device now, so change the event handlers\n            dragEventFor = eventsFor.touch;\n            return this.handleDragStart(e);\n        });\n        _defineProperty(this, \"onTouchEnd\", (e)=>{\n            // We're on a touch device now, so change the event handlers\n            dragEventFor = eventsFor.touch;\n            return this.handleDragStop(e);\n        });\n    }\n    componentDidMount() {\n        this.mounted = true;\n        // Touch handlers must be added with {passive: false} to be cancelable.\n        // https://developers.google.com/web/updates/2017/01/scrolling-intervention\n        const thisNode = this.findDOMNode();\n        if (thisNode) {\n            (0, _domFns.addEvent)(thisNode, eventsFor.touch.start, this.onTouchStart, {\n                passive: false\n            });\n        }\n    }\n    componentWillUnmount() {\n        this.mounted = false;\n        // Remove any leftover event handlers. Remove both touch and mouse handlers in case\n        // some browser quirk caused a touch event to fire during a mouse move, or vice versa.\n        const thisNode = this.findDOMNode();\n        if (thisNode) {\n            const { ownerDocument } = thisNode;\n            (0, _domFns.removeEvent)(ownerDocument, eventsFor.mouse.move, this.handleDrag);\n            (0, _domFns.removeEvent)(ownerDocument, eventsFor.touch.move, this.handleDrag);\n            (0, _domFns.removeEvent)(ownerDocument, eventsFor.mouse.stop, this.handleDragStop);\n            (0, _domFns.removeEvent)(ownerDocument, eventsFor.touch.stop, this.handleDragStop);\n            (0, _domFns.removeEvent)(thisNode, eventsFor.touch.start, this.onTouchStart, {\n                passive: false\n            });\n            if (this.props.enableUserSelectHack) (0, _domFns.scheduleRemoveUserSelectStyles)(ownerDocument);\n        }\n    }\n    // React Strict Mode compatibility: if `nodeRef` is passed, we will use it instead of trying to find\n    // the underlying DOM node ourselves. See the README for more information.\n    findDOMNode() /*: ?HTMLElement*/ {\n        return this.props?.nodeRef ? this.props?.nodeRef?.current : _reactDom.default.findDOMNode(this);\n    }\n    render() /*: React.Element<any>*/ {\n        // Reuse the child provided\n        // This makes it flexible to use whatever element is wanted (div, ul, etc)\n        return /*#__PURE__*/ React.cloneElement(React.Children.only(this.props.children), {\n            // Note: mouseMove handler is attached to document so it will still function\n            // when the user drags quickly and leaves the bounds of the element.\n            onMouseDown: this.onMouseDown,\n            onMouseUp: this.onMouseUp,\n            // onTouchStart is added on `componentDidMount` so they can be added with\n            // {passive: false}, which allows it to cancel. See\n            // https://developers.google.com/web/updates/2017/01/scrolling-intervention\n            onTouchEnd: this.onTouchEnd\n        });\n    }\n}\nexports[\"default\"] = DraggableCore;\n_defineProperty(DraggableCore, \"displayName\", \"DraggableCore\");\n_defineProperty(DraggableCore, \"propTypes\", {\n    /**\n   * `allowAnyClick` allows dragging using any mouse button.\n   * By default, we only accept the left button.\n   *\n   * Defaults to `false`.\n   */ allowAnyClick: _propTypes.default.bool,\n    /**\n   * `allowMobileScroll` turns off cancellation of the 'touchstart' event\n   * on mobile devices. Only enable this if you are having trouble with click\n   * events. Prefer using 'handle' / 'cancel' instead.\n   *\n   * Defaults to `false`.\n   */ allowMobileScroll: _propTypes.default.bool,\n    children: _propTypes.default.node.isRequired,\n    /**\n   * `disabled`, if true, stops the <Draggable> from dragging. All handlers,\n   * with the exception of `onMouseDown`, will not fire.\n   */ disabled: _propTypes.default.bool,\n    /**\n   * By default, we add 'user-select:none' attributes to the document body\n   * to prevent ugly text selection during drag. If this is causing problems\n   * for your app, set this to `false`.\n   */ enableUserSelectHack: _propTypes.default.bool,\n    /**\n   * `offsetParent`, if set, uses the passed DOM node to compute drag offsets\n   * instead of using the parent node.\n   */ offsetParent: function(props /*: DraggableCoreProps*/ , propName /*: $Keys<DraggableCoreProps>*/ ) {\n        if (props[propName] && props[propName].nodeType !== 1) {\n            throw new Error(\"Draggable's offsetParent must be a DOM Node.\");\n        }\n    },\n    /**\n   * `grid` specifies the x and y that dragging should snap to.\n   */ grid: _propTypes.default.arrayOf(_propTypes.default.number),\n    /**\n   * `handle` specifies a selector to be used as the handle that initiates drag.\n   *\n   * Example:\n   *\n   * ```jsx\n   *   let App = React.createClass({\n   *       render: function () {\n   *         return (\n   *            <Draggable handle=\".handle\">\n   *              <div>\n   *                  <div className=\"handle\">Click me to drag</div>\n   *                  <div>This is some other content</div>\n   *              </div>\n   *           </Draggable>\n   *         );\n   *       }\n   *   });\n   * ```\n   */ handle: _propTypes.default.string,\n    /**\n   * `cancel` specifies a selector to be used to prevent drag initialization.\n   *\n   * Example:\n   *\n   * ```jsx\n   *   let App = React.createClass({\n   *       render: function () {\n   *           return(\n   *               <Draggable cancel=\".cancel\">\n   *                   <div>\n   *                     <div className=\"cancel\">You can't drag from here</div>\n   *                     <div>Dragging here works fine</div>\n   *                   </div>\n   *               </Draggable>\n   *           );\n   *       }\n   *   });\n   * ```\n   */ cancel: _propTypes.default.string,\n    /* If running in React Strict mode, ReactDOM.findDOMNode() is deprecated.\n   * Unfortunately, in order for <Draggable> to work properly, we need raw access\n   * to the underlying DOM node. If you want to avoid the warning, pass a `nodeRef`\n   * as in this example:\n   *\n   * function MyComponent() {\n   *   const nodeRef = React.useRef(null);\n   *   return (\n   *     <Draggable nodeRef={nodeRef}>\n   *       <div ref={nodeRef}>Example Target</div>\n   *     </Draggable>\n   *   );\n   * }\n   *\n   * This can be used for arbitrarily nested components, so long as the ref ends up\n   * pointing to the actual child DOM node and not a custom component.\n   */ nodeRef: _propTypes.default.object,\n    /**\n   * Called when dragging starts.\n   * If this function returns the boolean false, dragging will be canceled.\n   */ onStart: _propTypes.default.func,\n    /**\n   * Called while dragging.\n   * If this function returns the boolean false, dragging will be canceled.\n   */ onDrag: _propTypes.default.func,\n    /**\n   * Called when dragging stops.\n   * If this function returns the boolean false, the drag will remain active.\n   */ onStop: _propTypes.default.func,\n    /**\n   * A workaround option which can be passed if onMouseDown needs to be accessed,\n   * since it'll always be blocked (as there is internal use of onMouseDown)\n   */ onMouseDown: _propTypes.default.func,\n    /**\n   * `scale`, if set, applies scaling while dragging an element\n   */ scale: _propTypes.default.number,\n    /**\n   * These properties should be defined on the child, not here.\n   */ className: _shims.dontSetMe,\n    style: _shims.dontSetMe,\n    transform: _shims.dontSetMe\n});\n_defineProperty(DraggableCore, \"defaultProps\", {\n    allowAnyClick: false,\n    // by default only accept left click\n    allowMobileScroll: false,\n    disabled: false,\n    enableUserSelectHack: true,\n    onStart: function() {},\n    onDrag: function() {},\n    onStop: function() {},\n    onMouseDown: function() {},\n    scale: 1\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtZHJhZ2dhYmxlL2J1aWxkL2Nqcy9EcmFnZ2FibGVDb3JlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWJBLDhDQUE2QztJQUMzQ0csT0FBTztBQUNULENBQUMsRUFBQztBQUNGRCxrQkFBZSxHQUFHLEtBQUs7QUFDdkIsSUFBSUcsUUFBUUMsd0JBQXdCQyxtQkFBT0EsQ0FBQyx3R0FBTztBQUNuRCxJQUFJQyxhQUFhQyx1QkFBdUJGLG1CQUFPQSxDQUFDLDREQUFZO0FBQzVELElBQUlHLFlBQVlELHVCQUF1QkYsbUJBQU9BLENBQUMsZ0hBQVc7QUFDMUQsSUFBSUksVUFBVUosbUJBQU9BLENBQUMsc0ZBQWdCO0FBQ3RDLElBQUlLLGVBQWVMLG1CQUFPQSxDQUFDLGdHQUFxQjtBQUNoRCxJQUFJTSxTQUFTTixtQkFBT0EsQ0FBQyxvRkFBZTtBQUNwQyxJQUFJTyxPQUFPTCx1QkFBdUJGLG1CQUFPQSxDQUFDLGdGQUFhO0FBQ3ZELFNBQVNFLHVCQUF1Qk0sQ0FBQztJQUFJLE9BQU9BLEtBQUtBLEVBQUVDLFVBQVUsR0FBR0QsSUFBSTtRQUFFWCxTQUFTVztJQUFFO0FBQUc7QUFDcEYsU0FBU1Qsd0JBQXdCUyxDQUFDLEVBQUVFLENBQUM7SUFBSSxJQUFJLGNBQWMsT0FBT0MsU0FBUyxJQUFJQyxJQUFJLElBQUlELFdBQVdFLElBQUksSUFBSUY7SUFBVyxPQUFPLENBQUNaLDBCQUEwQixTQUFVUyxDQUFDLEVBQUVFLENBQUM7UUFBSSxJQUFJLENBQUNBLEtBQUtGLEtBQUtBLEVBQUVDLFVBQVUsRUFBRSxPQUFPRDtRQUFHLElBQUlNLEdBQUdDLEdBQUdDLElBQUk7WUFBRUMsV0FBVztZQUFNcEIsU0FBU1c7UUFBRTtRQUFHLElBQUksU0FBU0EsS0FBSyxZQUFZLE9BQU9BLEtBQUssY0FBYyxPQUFPQSxHQUFHLE9BQU9RO1FBQUcsSUFBSUYsSUFBSUosSUFBSUcsSUFBSUQsR0FBRztZQUFFLElBQUlFLEVBQUVJLEdBQUcs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QUFzQjtJQUN0QkgsU0FBUyxZQUFhO0lBQ3RCaUIsUUFBUSxZQUFhO0lBQ3JCUyxRQUFRLFlBQWE7SUFDckJwRCxhQUFhLFlBQWE7SUFDMUJnRixPQUFPO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9haS1vcy1tdnAvLi9ub2RlX21vZHVsZXMvcmVhY3QtZHJhZ2dhYmxlL2J1aWxkL2Nqcy9EcmFnZ2FibGVDb3JlLmpzP2VkZTYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG52YXIgUmVhY3QgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIF9wcm9wVHlwZXMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJwcm9wLXR5cGVzXCIpKTtcbnZhciBfcmVhY3REb20gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJyZWFjdC1kb21cIikpO1xudmFyIF9kb21GbnMgPSByZXF1aXJlKFwiLi91dGlscy9kb21GbnNcIik7XG52YXIgX3Bvc2l0aW9uRm5zID0gcmVxdWlyZShcIi4vdXRpbHMvcG9zaXRpb25GbnNcIik7XG52YXIgX3NoaW1zID0gcmVxdWlyZShcIi4vdXRpbHMvc2hpbXNcIik7XG52YXIgX2xvZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXRpbHMvbG9nXCIpKTtcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoZSkgeyByZXR1cm4gZSAmJiBlLl9fZXNNb2R1bGUgPyBlIDogeyBkZWZhdWx0OiBlIH07IH1cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKGUsIHQpIHsgaWYgKFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgV2Vha01hcCkgdmFyIHIgPSBuZXcgV2Vha01hcCgpLCBuID0gbmV3IFdlYWtNYXAoKTsgcmV0dXJuIChfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZCA9IGZ1bmN0aW9uIChlLCB0KSB7IGlmICghdCAmJiBlICYmIGUuX19lc01vZHVsZSkgcmV0dXJuIGU7IHZhciBvLCBpLCBmID0geyBfX3Byb3RvX186IG51bGwsIGRlZmF1bHQ6IGUgfTsgaWYgKG51bGwgPT09IGUgfHwgXCJvYmplY3RcIiAhPSB0eXBlb2YgZSAmJiBcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIGUpIHJldHVybiBmOyBpZiAobyA9IHQgPyBuIDogcikgeyBpZiAoby5oYXMoZSkpIHJldHVybiBvLmdldChlKTsgby5zZXQoZSwgZik7IH0gZm9yIChjb25zdCB0IGluIGUpIFwiZGVmYXVsdFwiICE9PSB0ICYmIHt9Lmhhc093blByb3BlcnR5LmNhbGwoZSwgdCkgJiYgKChpID0gKG8gPSBPYmplY3QuZGVmaW5lUHJvcGVydHkpICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgdCkpICYmIChpLmdldCB8fCBpLnNldCkgPyBvKGYsIHQsIGkpIDogZlt0XSA9IGVbdF0pOyByZXR1cm4gZjsgfSkoZSwgdCk7IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0KSB7IHJldHVybiAociA9IF90b1Byb3BlcnR5S2V5KHIpKSBpbiBlID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIHsgdmFsdWU6IHQsIGVudW1lcmFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwLCB3cml0YWJsZTogITAgfSkgOiBlW3JdID0gdCwgZTsgfVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkodCkgeyB2YXIgaSA9IF90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTsgcmV0dXJuIFwic3ltYm9sXCIgPT0gdHlwZW9mIGkgPyBpIDogaSArIFwiXCI7IH1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7IGlmIChcIm9iamVjdFwiICE9IHR5cGVvZiB0IHx8ICF0KSByZXR1cm4gdDsgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmICh2b2lkIDAgIT09IGUpIHsgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7IGlmIChcIm9iamVjdFwiICE9IHR5cGVvZiBpKSByZXR1cm4gaTsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7IH1cbi8qOjogaW1wb3J0IHR5cGUge0V2ZW50SGFuZGxlciwgTW91c2VUb3VjaEV2ZW50fSBmcm9tICcuL3V0aWxzL3R5cGVzJzsqL1xuLyo6OiBpbXBvcnQgdHlwZSB7RWxlbWVudCBhcyBSZWFjdEVsZW1lbnR9IGZyb20gJ3JlYWN0JzsqL1xuLy8gU2ltcGxlIGFic3RyYWN0aW9uIGZvciBkcmFnZ2luZyBldmVudHMgbmFtZXMuXG5jb25zdCBldmVudHNGb3IgPSB7XG4gIHRvdWNoOiB7XG4gICAgc3RhcnQ6ICd0b3VjaHN0YXJ0JyxcbiAgICBtb3ZlOiAndG91Y2htb3ZlJyxcbiAgICBzdG9wOiAndG91Y2hlbmQnXG4gIH0sXG4gIG1vdXNlOiB7XG4gICAgc3RhcnQ6ICdtb3VzZWRvd24nLFxuICAgIG1vdmU6ICdtb3VzZW1vdmUnLFxuICAgIHN0b3A6ICdtb3VzZXVwJ1xuICB9XG59O1xuXG4vLyBEZWZhdWx0IHRvIG1vdXNlIGV2ZW50cy5cbmxldCBkcmFnRXZlbnRGb3IgPSBldmVudHNGb3IubW91c2U7XG4vKjo6IGV4cG9ydCB0eXBlIERyYWdnYWJsZURhdGEgPSB7XG4gIG5vZGU6IEhUTUxFbGVtZW50LFxuICB4OiBudW1iZXIsIHk6IG51bWJlcixcbiAgZGVsdGFYOiBudW1iZXIsIGRlbHRhWTogbnVtYmVyLFxuICBsYXN0WDogbnVtYmVyLCBsYXN0WTogbnVtYmVyLFxufTsqL1xuLyo6OiBleHBvcnQgdHlwZSBEcmFnZ2FibGVFdmVudEhhbmRsZXIgPSAoZTogTW91c2VFdmVudCwgZGF0YTogRHJhZ2dhYmxlRGF0YSkgPT4gdm9pZCB8IGZhbHNlOyovXG4vKjo6IGV4cG9ydCB0eXBlIENvbnRyb2xQb3NpdGlvbiA9IHt4OiBudW1iZXIsIHk6IG51bWJlcn07Ki9cbi8qOjogZXhwb3J0IHR5cGUgUG9zaXRpb25PZmZzZXRDb250cm9sUG9zaXRpb24gPSB7eDogbnVtYmVyfHN0cmluZywgeTogbnVtYmVyfHN0cmluZ307Ki9cbi8qOjogZXhwb3J0IHR5cGUgRHJhZ2dhYmxlQ29yZURlZmF1bHRQcm9wcyA9IHtcbiAgYWxsb3dBbnlDbGljazogYm9vbGVhbixcbiAgYWxsb3dNb2JpbGVTY3JvbGw6IGJvb2xlYW4sXG4gIGRpc2FibGVkOiBib29sZWFuLFxuICBlbmFibGVVc2VyU2VsZWN0SGFjazogYm9vbGVhbixcbiAgb25TdGFydDogRHJhZ2dhYmxlRXZlbnRIYW5kbGVyLFxuICBvbkRyYWc6IERyYWdnYWJsZUV2ZW50SGFuZGxlcixcbiAgb25TdG9wOiBEcmFnZ2FibGVFdmVudEhhbmRsZXIsXG4gIG9uTW91c2VEb3duOiAoZTogTW91c2VFdmVudCkgPT4gdm9pZCxcbiAgc2NhbGU6IG51bWJlcixcbn07Ki9cbi8qOjogZXhwb3J0IHR5cGUgRHJhZ2dhYmxlQ29yZVByb3BzID0ge1xuICAuLi5EcmFnZ2FibGVDb3JlRGVmYXVsdFByb3BzLFxuICBjYW5jZWw6IHN0cmluZyxcbiAgY2hpbGRyZW46IFJlYWN0RWxlbWVudDxhbnk+LFxuICBvZmZzZXRQYXJlbnQ6IEhUTUxFbGVtZW50LFxuICBncmlkOiBbbnVtYmVyLCBudW1iZXJdLFxuICBoYW5kbGU6IHN0cmluZyxcbiAgbm9kZVJlZj86ID9SZWFjdC5FbGVtZW50UmVmPGFueT4sXG59OyovXG4vL1xuLy8gRGVmaW5lIDxEcmFnZ2FibGVDb3JlPi5cbi8vXG4vLyA8RHJhZ2dhYmxlQ29yZT4gaXMgZm9yIGFkdmFuY2VkIHVzYWdlIG9mIDxEcmFnZ2FibGU+LiBJdCBtYWludGFpbnMgbWluaW1hbCBpbnRlcm5hbCBzdGF0ZSBzbyBpdCBjYW5cbi8vIHdvcmsgd2VsbCB3aXRoIGxpYnJhcmllcyB0aGF0IHJlcXVpcmUgbW9yZSBjb250cm9sIG92ZXIgdGhlIGVsZW1lbnQuXG4vL1xuXG5jbGFzcyBEcmFnZ2FibGVDb3JlIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IC8qOjogPERyYWdnYWJsZUNvcmVQcm9wcz4qL3tcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJkcmFnZ2luZ1wiLCBmYWxzZSk7XG4gICAgLy8gVXNlZCB3aGlsZSBkcmFnZ2luZyB0byBkZXRlcm1pbmUgZGVsdGFzLlxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxhc3RYXCIsIE5hTik7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwibGFzdFlcIiwgTmFOKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0b3VjaElkZW50aWZpZXJcIiwgbnVsbCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwibW91bnRlZFwiLCBmYWxzZSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiaGFuZGxlRHJhZ1N0YXJ0XCIsIGUgPT4ge1xuICAgICAgLy8gTWFrZSBpdCBwb3NzaWJsZSB0byBhdHRhY2ggZXZlbnQgaGFuZGxlcnMgb24gdG9wIG9mIHRoaXMgb25lLlxuICAgICAgdGhpcy5wcm9wcy5vbk1vdXNlRG93bihlKTtcblxuICAgICAgLy8gT25seSBhY2NlcHQgbGVmdC1jbGlja3MuXG4gICAgICBpZiAoIXRoaXMucHJvcHMuYWxsb3dBbnlDbGljayAmJiB0eXBlb2YgZS5idXR0b24gPT09ICdudW1iZXInICYmIGUuYnV0dG9uICE9PSAwKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgIC8vIEdldCBub2Rlcy4gQmUgc3VyZSB0byBncmFiIHJlbGF0aXZlIGRvY3VtZW50IChjb3VsZCBiZSBpZnJhbWVkKVxuICAgICAgY29uc3QgdGhpc05vZGUgPSB0aGlzLmZpbmRET01Ob2RlKCk7XG4gICAgICBpZiAoIXRoaXNOb2RlIHx8ICF0aGlzTm9kZS5vd25lckRvY3VtZW50IHx8ICF0aGlzTm9kZS5vd25lckRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCc8RHJhZ2dhYmxlQ29yZT4gbm90IG1vdW50ZWQgb24gRHJhZ1N0YXJ0IScpO1xuICAgICAgfVxuICAgICAgY29uc3Qge1xuICAgICAgICBvd25lckRvY3VtZW50XG4gICAgICB9ID0gdGhpc05vZGU7XG5cbiAgICAgIC8vIFNob3J0IGNpcmN1aXQgaWYgaGFuZGxlIG9yIGNhbmNlbCBwcm9wIHdhcyBwcm92aWRlZCBhbmQgc2VsZWN0b3IgZG9lc24ndCBtYXRjaC5cbiAgICAgIGlmICh0aGlzLnByb3BzLmRpc2FibGVkIHx8ICEoZS50YXJnZXQgaW5zdGFuY2VvZiBvd25lckRvY3VtZW50LmRlZmF1bHRWaWV3Lk5vZGUpIHx8IHRoaXMucHJvcHMuaGFuZGxlICYmICEoMCwgX2RvbUZucy5tYXRjaGVzU2VsZWN0b3JBbmRQYXJlbnRzVG8pKGUudGFyZ2V0LCB0aGlzLnByb3BzLmhhbmRsZSwgdGhpc05vZGUpIHx8IHRoaXMucHJvcHMuY2FuY2VsICYmICgwLCBfZG9tRm5zLm1hdGNoZXNTZWxlY3RvckFuZFBhcmVudHNUbykoZS50YXJnZXQsIHRoaXMucHJvcHMuY2FuY2VsLCB0aGlzTm9kZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBQcmV2ZW50IHNjcm9sbGluZyBvbiBtb2JpbGUgZGV2aWNlcywgbGlrZSBpcGFkL2lwaG9uZS5cbiAgICAgIC8vIEltcG9ydGFudCB0aGF0IHRoaXMgaXMgYWZ0ZXIgaGFuZGxlL2NhbmNlbC5cbiAgICAgIGlmIChlLnR5cGUgPT09ICd0b3VjaHN0YXJ0JyAmJiAhdGhpcy5wcm9wcy5hbGxvd01vYmlsZVNjcm9sbCkgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAvLyBTZXQgdG91Y2ggaWRlbnRpZmllciBpbiBjb21wb25lbnQgc3RhdGUgaWYgdGhpcyBpcyBhIHRvdWNoIGV2ZW50LiBUaGlzIGFsbG93cyB1cyB0b1xuICAgICAgLy8gZGlzdGluZ3Vpc2ggYmV0d2VlbiBpbmRpdmlkdWFsIHRvdWNoZXMgb24gbXVsdGl0b3VjaCBzY3JlZW5zIGJ5IGlkZW50aWZ5aW5nIHdoaWNoXG4gICAgICAvLyB0b3VjaHBvaW50IHdhcyBzZXQgdG8gdGhpcyBlbGVtZW50LlxuICAgICAgY29uc3QgdG91Y2hJZGVudGlmaWVyID0gKDAsIF9kb21GbnMuZ2V0VG91Y2hJZGVudGlmaWVyKShlKTtcbiAgICAgIHRoaXMudG91Y2hJZGVudGlmaWVyID0gdG91Y2hJZGVudGlmaWVyO1xuXG4gICAgICAvLyBHZXQgdGhlIGN1cnJlbnQgZHJhZyBwb2ludCBmcm9tIHRoZSBldmVudC4gVGhpcyBpcyB1c2VkIGFzIHRoZSBvZmZzZXQuXG4gICAgICBjb25zdCBwb3NpdGlvbiA9ICgwLCBfcG9zaXRpb25GbnMuZ2V0Q29udHJvbFBvc2l0aW9uKShlLCB0b3VjaElkZW50aWZpZXIsIHRoaXMpO1xuICAgICAgaWYgKHBvc2l0aW9uID09IG51bGwpIHJldHVybjsgLy8gbm90IHBvc3NpYmxlIGJ1dCBzYXRpc2ZpZXMgZmxvd1xuICAgICAgY29uc3Qge1xuICAgICAgICB4LFxuICAgICAgICB5XG4gICAgICB9ID0gcG9zaXRpb247XG5cbiAgICAgIC8vIENyZWF0ZSBhbiBldmVudCBvYmplY3Qgd2l0aCBhbGwgdGhlIGRhdGEgcGFyZW50cyBuZWVkIHRvIG1ha2UgYSBkZWNpc2lvbiBoZXJlLlxuICAgICAgY29uc3QgY29yZUV2ZW50ID0gKDAsIF9wb3NpdGlvbkZucy5jcmVhdGVDb3JlRGF0YSkodGhpcywgeCwgeSk7XG4gICAgICAoMCwgX2xvZy5kZWZhdWx0KSgnRHJhZ2dhYmxlQ29yZTogaGFuZGxlRHJhZ1N0YXJ0OiAlaicsIGNvcmVFdmVudCk7XG5cbiAgICAgIC8vIENhbGwgZXZlbnQgaGFuZGxlci4gSWYgaXQgcmV0dXJucyBleHBsaWNpdCBmYWxzZSwgY2FuY2VsLlxuICAgICAgKDAsIF9sb2cuZGVmYXVsdCkoJ2NhbGxpbmcnLCB0aGlzLnByb3BzLm9uU3RhcnQpO1xuICAgICAgY29uc3Qgc2hvdWxkVXBkYXRlID0gdGhpcy5wcm9wcy5vblN0YXJ0KGUsIGNvcmVFdmVudCk7XG4gICAgICBpZiAoc2hvdWxkVXBkYXRlID09PSBmYWxzZSB8fCB0aGlzLm1vdW50ZWQgPT09IGZhbHNlKSByZXR1cm47XG5cbiAgICAgIC8vIEFkZCBhIHN0eWxlIHRvIHRoZSBib2R5IHRvIGRpc2FibGUgdXNlci1zZWxlY3QuIFRoaXMgcHJldmVudHMgdGV4dCBmcm9tXG4gICAgICAvLyBiZWluZyBzZWxlY3RlZCBhbGwgb3ZlciB0aGUgcGFnZS5cbiAgICAgIGlmICh0aGlzLnByb3BzLmVuYWJsZVVzZXJTZWxlY3RIYWNrKSAoMCwgX2RvbUZucy5hZGRVc2VyU2VsZWN0U3R5bGVzKShvd25lckRvY3VtZW50KTtcblxuICAgICAgLy8gSW5pdGlhdGUgZHJhZ2dpbmcuIFNldCB0aGUgY3VycmVudCB4IGFuZCB5IGFzIG9mZnNldHNcbiAgICAgIC8vIHNvIHdlIGtub3cgaG93IG11Y2ggd2UndmUgbW92ZWQgZHVyaW5nIHRoZSBkcmFnLiBUaGlzIGFsbG93cyB1c1xuICAgICAgLy8gdG8gZHJhZyBlbGVtZW50cyBhcm91bmQgZXZlbiBpZiB0aGV5IGhhdmUgYmVlbiBtb3ZlZCwgd2l0aG91dCBpc3N1ZS5cbiAgICAgIHRoaXMuZHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgdGhpcy5sYXN0WCA9IHg7XG4gICAgICB0aGlzLmxhc3RZID0geTtcblxuICAgICAgLy8gQWRkIGV2ZW50cyB0byB0aGUgZG9jdW1lbnQgZGlyZWN0bHkgc28gd2UgY2F0Y2ggd2hlbiB0aGUgdXNlcidzIG1vdXNlL3RvdWNoIG1vdmVzIG91dHNpZGUgb2ZcbiAgICAgIC8vIHRoaXMgZWxlbWVudC4gV2UgdXNlIGRpZmZlcmVudCBldmVudHMgZGVwZW5kaW5nIG9uIHdoZXRoZXIgb3Igbm90IHdlIGhhdmUgZGV0ZWN0ZWQgdGhhdCB0aGlzXG4gICAgICAvLyBpcyBhIHRvdWNoLWNhcGFibGUgZGV2aWNlLlxuICAgICAgKDAsIF9kb21GbnMuYWRkRXZlbnQpKG93bmVyRG9jdW1lbnQsIGRyYWdFdmVudEZvci5tb3ZlLCB0aGlzLmhhbmRsZURyYWcpO1xuICAgICAgKDAsIF9kb21GbnMuYWRkRXZlbnQpKG93bmVyRG9jdW1lbnQsIGRyYWdFdmVudEZvci5zdG9wLCB0aGlzLmhhbmRsZURyYWdTdG9wKTtcbiAgICB9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJoYW5kbGVEcmFnXCIsIGUgPT4ge1xuICAgICAgLy8gR2V0IHRoZSBjdXJyZW50IGRyYWcgcG9pbnQgZnJvbSB0aGUgZXZlbnQuIFRoaXMgaXMgdXNlZCBhcyB0aGUgb2Zmc2V0LlxuICAgICAgY29uc3QgcG9zaXRpb24gPSAoMCwgX3Bvc2l0aW9uRm5zLmdldENvbnRyb2xQb3NpdGlvbikoZSwgdGhpcy50b3VjaElkZW50aWZpZXIsIHRoaXMpO1xuICAgICAgaWYgKHBvc2l0aW9uID09IG51bGwpIHJldHVybjtcbiAgICAgIGxldCB7XG4gICAgICAgIHgsXG4gICAgICAgIHlcbiAgICAgIH0gPSBwb3NpdGlvbjtcblxuICAgICAgLy8gU25hcCB0byBncmlkIGlmIHByb3AgaGFzIGJlZW4gcHJvdmlkZWRcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMucHJvcHMuZ3JpZCkpIHtcbiAgICAgICAgbGV0IGRlbHRhWCA9IHggLSB0aGlzLmxhc3RYLFxuICAgICAgICAgIGRlbHRhWSA9IHkgLSB0aGlzLmxhc3RZO1xuICAgICAgICBbZGVsdGFYLCBkZWx0YVldID0gKDAsIF9wb3NpdGlvbkZucy5zbmFwVG9HcmlkKSh0aGlzLnByb3BzLmdyaWQsIGRlbHRhWCwgZGVsdGFZKTtcbiAgICAgICAgaWYgKCFkZWx0YVggJiYgIWRlbHRhWSkgcmV0dXJuOyAvLyBza2lwIHVzZWxlc3MgZHJhZ1xuICAgICAgICB4ID0gdGhpcy5sYXN0WCArIGRlbHRhWCwgeSA9IHRoaXMubGFzdFkgKyBkZWx0YVk7XG4gICAgICB9XG4gICAgICBjb25zdCBjb3JlRXZlbnQgPSAoMCwgX3Bvc2l0aW9uRm5zLmNyZWF0ZUNvcmVEYXRhKSh0aGlzLCB4LCB5KTtcbiAgICAgICgwLCBfbG9nLmRlZmF1bHQpKCdEcmFnZ2FibGVDb3JlOiBoYW5kbGVEcmFnOiAlaicsIGNvcmVFdmVudCk7XG5cbiAgICAgIC8vIENhbGwgZXZlbnQgaGFuZGxlci4gSWYgaXQgcmV0dXJucyBleHBsaWNpdCBmYWxzZSwgdHJpZ2dlciBlbmQuXG4gICAgICBjb25zdCBzaG91bGRVcGRhdGUgPSB0aGlzLnByb3BzLm9uRHJhZyhlLCBjb3JlRXZlbnQpO1xuICAgICAgaWYgKHNob3VsZFVwZGF0ZSA9PT0gZmFsc2UgfHwgdGhpcy5tb3VudGVkID09PSBmYWxzZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vICRGbG93SWdub3JlXG4gICAgICAgICAgdGhpcy5oYW5kbGVEcmFnU3RvcChuZXcgTW91c2VFdmVudCgnbW91c2V1cCcpKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgLy8gT2xkIGJyb3dzZXJzXG4gICAgICAgICAgY29uc3QgZXZlbnQgPSAoKGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdNb3VzZUV2ZW50cycpIC8qOiBhbnkqLykgLyo6IE1vdXNlVG91Y2hFdmVudCovKTtcbiAgICAgICAgICAvLyBJIHNlZSB3aHkgdGhpcyBpbnNhbml0eSB3YXMgZGVwcmVjYXRlZFxuICAgICAgICAgIC8vICRGbG93SWdub3JlXG4gICAgICAgICAgZXZlbnQuaW5pdE1vdXNlRXZlbnQoJ21vdXNldXAnLCB0cnVlLCB0cnVlLCB3aW5kb3csIDAsIDAsIDAsIDAsIDAsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAwLCBudWxsKTtcbiAgICAgICAgICB0aGlzLmhhbmRsZURyYWdTdG9wKGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmxhc3RYID0geDtcbiAgICAgIHRoaXMubGFzdFkgPSB5O1xuICAgIH0pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImhhbmRsZURyYWdTdG9wXCIsIGUgPT4ge1xuICAgICAgaWYgKCF0aGlzLmRyYWdnaW5nKSByZXR1cm47XG4gICAgICBjb25zdCBwb3NpdGlvbiA9ICgwLCBfcG9zaXRpb25GbnMuZ2V0Q29udHJvbFBvc2l0aW9uKShlLCB0aGlzLnRvdWNoSWRlbnRpZmllciwgdGhpcyk7XG4gICAgICBpZiAocG9zaXRpb24gPT0gbnVsbCkgcmV0dXJuO1xuICAgICAgbGV0IHtcbiAgICAgICAgeCxcbiAgICAgICAgeVxuICAgICAgfSA9IHBvc2l0aW9uO1xuXG4gICAgICAvLyBTbmFwIHRvIGdyaWQgaWYgcHJvcCBoYXMgYmVlbiBwcm92aWRlZFxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5wcm9wcy5ncmlkKSkge1xuICAgICAgICBsZXQgZGVsdGFYID0geCAtIHRoaXMubGFzdFggfHwgMDtcbiAgICAgICAgbGV0IGRlbHRhWSA9IHkgLSB0aGlzLmxhc3RZIHx8IDA7XG4gICAgICAgIFtkZWx0YVgsIGRlbHRhWV0gPSAoMCwgX3Bvc2l0aW9uRm5zLnNuYXBUb0dyaWQpKHRoaXMucHJvcHMuZ3JpZCwgZGVsdGFYLCBkZWx0YVkpO1xuICAgICAgICB4ID0gdGhpcy5sYXN0WCArIGRlbHRhWCwgeSA9IHRoaXMubGFzdFkgKyBkZWx0YVk7XG4gICAgICB9XG4gICAgICBjb25zdCBjb3JlRXZlbnQgPSAoMCwgX3Bvc2l0aW9uRm5zLmNyZWF0ZUNvcmVEYXRhKSh0aGlzLCB4LCB5KTtcblxuICAgICAgLy8gQ2FsbCBldmVudCBoYW5kbGVyXG4gICAgICBjb25zdCBzaG91bGRDb250aW51ZSA9IHRoaXMucHJvcHMub25TdG9wKGUsIGNvcmVFdmVudCk7XG4gICAgICBpZiAoc2hvdWxkQ29udGludWUgPT09IGZhbHNlIHx8IHRoaXMubW91bnRlZCA9PT0gZmFsc2UpIHJldHVybiBmYWxzZTtcbiAgICAgIGNvbnN0IHRoaXNOb2RlID0gdGhpcy5maW5kRE9NTm9kZSgpO1xuICAgICAgaWYgKHRoaXNOb2RlKSB7XG4gICAgICAgIC8vIFJlbW92ZSB1c2VyLXNlbGVjdCBoYWNrXG4gICAgICAgIGlmICh0aGlzLnByb3BzLmVuYWJsZVVzZXJTZWxlY3RIYWNrKSAoMCwgX2RvbUZucy5zY2hlZHVsZVJlbW92ZVVzZXJTZWxlY3RTdHlsZXMpKHRoaXNOb2RlLm93bmVyRG9jdW1lbnQpO1xuICAgICAgfVxuICAgICAgKDAsIF9sb2cuZGVmYXVsdCkoJ0RyYWdnYWJsZUNvcmU6IGhhbmRsZURyYWdTdG9wOiAlaicsIGNvcmVFdmVudCk7XG5cbiAgICAgIC8vIFJlc2V0IHRoZSBlbC5cbiAgICAgIHRoaXMuZHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgIHRoaXMubGFzdFggPSBOYU47XG4gICAgICB0aGlzLmxhc3RZID0gTmFOO1xuICAgICAgaWYgKHRoaXNOb2RlKSB7XG4gICAgICAgIC8vIFJlbW92ZSBldmVudCBoYW5kbGVyc1xuICAgICAgICAoMCwgX2xvZy5kZWZhdWx0KSgnRHJhZ2dhYmxlQ29yZTogUmVtb3ZpbmcgaGFuZGxlcnMnKTtcbiAgICAgICAgKDAsIF9kb21GbnMucmVtb3ZlRXZlbnQpKHRoaXNOb2RlLm93bmVyRG9jdW1lbnQsIGRyYWdFdmVudEZvci5tb3ZlLCB0aGlzLmhhbmRsZURyYWcpO1xuICAgICAgICAoMCwgX2RvbUZucy5yZW1vdmVFdmVudCkodGhpc05vZGUub3duZXJEb2N1bWVudCwgZHJhZ0V2ZW50Rm9yLnN0b3AsIHRoaXMuaGFuZGxlRHJhZ1N0b3ApO1xuICAgICAgfVxuICAgIH0pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm9uTW91c2VEb3duXCIsIGUgPT4ge1xuICAgICAgZHJhZ0V2ZW50Rm9yID0gZXZlbnRzRm9yLm1vdXNlOyAvLyBvbiB0b3VjaHNjcmVlbiBsYXB0b3BzIHdlIGNvdWxkIHN3aXRjaCBiYWNrIHRvIG1vdXNlXG5cbiAgICAgIHJldHVybiB0aGlzLmhhbmRsZURyYWdTdGFydChlKTtcbiAgICB9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJvbk1vdXNlVXBcIiwgZSA9PiB7XG4gICAgICBkcmFnRXZlbnRGb3IgPSBldmVudHNGb3IubW91c2U7XG4gICAgICByZXR1cm4gdGhpcy5oYW5kbGVEcmFnU3RvcChlKTtcbiAgICB9KTtcbiAgICAvLyBTYW1lIGFzIG9uTW91c2VEb3duIChzdGFydCBkcmFnKSwgYnV0IG5vdyBjb25zaWRlciB0aGlzIGEgdG91Y2ggZGV2aWNlLlxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm9uVG91Y2hTdGFydFwiLCBlID0+IHtcbiAgICAgIC8vIFdlJ3JlIG9uIGEgdG91Y2ggZGV2aWNlIG5vdywgc28gY2hhbmdlIHRoZSBldmVudCBoYW5kbGVyc1xuICAgICAgZHJhZ0V2ZW50Rm9yID0gZXZlbnRzRm9yLnRvdWNoO1xuICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlRHJhZ1N0YXJ0KGUpO1xuICAgIH0pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm9uVG91Y2hFbmRcIiwgZSA9PiB7XG4gICAgICAvLyBXZSdyZSBvbiBhIHRvdWNoIGRldmljZSBub3csIHNvIGNoYW5nZSB0aGUgZXZlbnQgaGFuZGxlcnNcbiAgICAgIGRyYWdFdmVudEZvciA9IGV2ZW50c0Zvci50b3VjaDtcbiAgICAgIHJldHVybiB0aGlzLmhhbmRsZURyYWdTdG9wKGUpO1xuICAgIH0pO1xuICB9XG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIHRoaXMubW91bnRlZCA9IHRydWU7XG4gICAgLy8gVG91Y2ggaGFuZGxlcnMgbXVzdCBiZSBhZGRlZCB3aXRoIHtwYXNzaXZlOiBmYWxzZX0gdG8gYmUgY2FuY2VsYWJsZS5cbiAgICAvLyBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS93ZWIvdXBkYXRlcy8yMDE3LzAxL3Njcm9sbGluZy1pbnRlcnZlbnRpb25cbiAgICBjb25zdCB0aGlzTm9kZSA9IHRoaXMuZmluZERPTU5vZGUoKTtcbiAgICBpZiAodGhpc05vZGUpIHtcbiAgICAgICgwLCBfZG9tRm5zLmFkZEV2ZW50KSh0aGlzTm9kZSwgZXZlbnRzRm9yLnRvdWNoLnN0YXJ0LCB0aGlzLm9uVG91Y2hTdGFydCwge1xuICAgICAgICBwYXNzaXZlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIHRoaXMubW91bnRlZCA9IGZhbHNlO1xuICAgIC8vIFJlbW92ZSBhbnkgbGVmdG92ZXIgZXZlbnQgaGFuZGxlcnMuIFJlbW92ZSBib3RoIHRvdWNoIGFuZCBtb3VzZSBoYW5kbGVycyBpbiBjYXNlXG4gICAgLy8gc29tZSBicm93c2VyIHF1aXJrIGNhdXNlZCBhIHRvdWNoIGV2ZW50IHRvIGZpcmUgZHVyaW5nIGEgbW91c2UgbW92ZSwgb3IgdmljZSB2ZXJzYS5cbiAgICBjb25zdCB0aGlzTm9kZSA9IHRoaXMuZmluZERPTU5vZGUoKTtcbiAgICBpZiAodGhpc05vZGUpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgb3duZXJEb2N1bWVudFxuICAgICAgfSA9IHRoaXNOb2RlO1xuICAgICAgKDAsIF9kb21GbnMucmVtb3ZlRXZlbnQpKG93bmVyRG9jdW1lbnQsIGV2ZW50c0Zvci5tb3VzZS5tb3ZlLCB0aGlzLmhhbmRsZURyYWcpO1xuICAgICAgKDAsIF9kb21GbnMucmVtb3ZlRXZlbnQpKG93bmVyRG9jdW1lbnQsIGV2ZW50c0Zvci50b3VjaC5tb3ZlLCB0aGlzLmhhbmRsZURyYWcpO1xuICAgICAgKDAsIF9kb21GbnMucmVtb3ZlRXZlbnQpKG93bmVyRG9jdW1lbnQsIGV2ZW50c0Zvci5tb3VzZS5zdG9wLCB0aGlzLmhhbmRsZURyYWdTdG9wKTtcbiAgICAgICgwLCBfZG9tRm5zLnJlbW92ZUV2ZW50KShvd25lckRvY3VtZW50LCBldmVudHNGb3IudG91Y2guc3RvcCwgdGhpcy5oYW5kbGVEcmFnU3RvcCk7XG4gICAgICAoMCwgX2RvbUZucy5yZW1vdmVFdmVudCkodGhpc05vZGUsIGV2ZW50c0Zvci50b3VjaC5zdGFydCwgdGhpcy5vblRvdWNoU3RhcnQsIHtcbiAgICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgaWYgKHRoaXMucHJvcHMuZW5hYmxlVXNlclNlbGVjdEhhY2spICgwLCBfZG9tRm5zLnNjaGVkdWxlUmVtb3ZlVXNlclNlbGVjdFN0eWxlcykob3duZXJEb2N1bWVudCk7XG4gICAgfVxuICB9XG5cbiAgLy8gUmVhY3QgU3RyaWN0IE1vZGUgY29tcGF0aWJpbGl0eTogaWYgYG5vZGVSZWZgIGlzIHBhc3NlZCwgd2Ugd2lsbCB1c2UgaXQgaW5zdGVhZCBvZiB0cnlpbmcgdG8gZmluZFxuICAvLyB0aGUgdW5kZXJseWluZyBET00gbm9kZSBvdXJzZWx2ZXMuIFNlZSB0aGUgUkVBRE1FIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICBmaW5kRE9NTm9kZSgpIC8qOiA/SFRNTEVsZW1lbnQqL3tcbiAgICByZXR1cm4gdGhpcy5wcm9wcz8ubm9kZVJlZiA/IHRoaXMucHJvcHM/Lm5vZGVSZWY/LmN1cnJlbnQgOiBfcmVhY3REb20uZGVmYXVsdC5maW5kRE9NTm9kZSh0aGlzKTtcbiAgfVxuICByZW5kZXIoKSAvKjogUmVhY3QuRWxlbWVudDxhbnk+Ki97XG4gICAgLy8gUmV1c2UgdGhlIGNoaWxkIHByb3ZpZGVkXG4gICAgLy8gVGhpcyBtYWtlcyBpdCBmbGV4aWJsZSB0byB1c2Ugd2hhdGV2ZXIgZWxlbWVudCBpcyB3YW50ZWQgKGRpdiwgdWwsIGV0YylcbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNsb25lRWxlbWVudChSZWFjdC5DaGlsZHJlbi5vbmx5KHRoaXMucHJvcHMuY2hpbGRyZW4pLCB7XG4gICAgICAvLyBOb3RlOiBtb3VzZU1vdmUgaGFuZGxlciBpcyBhdHRhY2hlZCB0byBkb2N1bWVudCBzbyBpdCB3aWxsIHN0aWxsIGZ1bmN0aW9uXG4gICAgICAvLyB3aGVuIHRoZSB1c2VyIGRyYWdzIHF1aWNrbHkgYW5kIGxlYXZlcyB0aGUgYm91bmRzIG9mIHRoZSBlbGVtZW50LlxuICAgICAgb25Nb3VzZURvd246IHRoaXMub25Nb3VzZURvd24sXG4gICAgICBvbk1vdXNlVXA6IHRoaXMub25Nb3VzZVVwLFxuICAgICAgLy8gb25Ub3VjaFN0YXJ0IGlzIGFkZGVkIG9uIGBjb21wb25lbnREaWRNb3VudGAgc28gdGhleSBjYW4gYmUgYWRkZWQgd2l0aFxuICAgICAgLy8ge3Bhc3NpdmU6IGZhbHNlfSwgd2hpY2ggYWxsb3dzIGl0IHRvIGNhbmNlbC4gU2VlXG4gICAgICAvLyBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS93ZWIvdXBkYXRlcy8yMDE3LzAxL3Njcm9sbGluZy1pbnRlcnZlbnRpb25cbiAgICAgIG9uVG91Y2hFbmQ6IHRoaXMub25Ub3VjaEVuZFxuICAgIH0pO1xuICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBEcmFnZ2FibGVDb3JlO1xuX2RlZmluZVByb3BlcnR5KERyYWdnYWJsZUNvcmUsIFwiZGlzcGxheU5hbWVcIiwgJ0RyYWdnYWJsZUNvcmUnKTtcbl9kZWZpbmVQcm9wZXJ0eShEcmFnZ2FibGVDb3JlLCBcInByb3BUeXBlc1wiLCB7XG4gIC8qKlxuICAgKiBgYWxsb3dBbnlDbGlja2AgYWxsb3dzIGRyYWdnaW5nIHVzaW5nIGFueSBtb3VzZSBidXR0b24uXG4gICAqIEJ5IGRlZmF1bHQsIHdlIG9ubHkgYWNjZXB0IHRoZSBsZWZ0IGJ1dHRvbi5cbiAgICpcbiAgICogRGVmYXVsdHMgdG8gYGZhbHNlYC5cbiAgICovXG4gIGFsbG93QW55Q2xpY2s6IF9wcm9wVHlwZXMuZGVmYXVsdC5ib29sLFxuICAvKipcbiAgICogYGFsbG93TW9iaWxlU2Nyb2xsYCB0dXJucyBvZmYgY2FuY2VsbGF0aW9uIG9mIHRoZSAndG91Y2hzdGFydCcgZXZlbnRcbiAgICogb24gbW9iaWxlIGRldmljZXMuIE9ubHkgZW5hYmxlIHRoaXMgaWYgeW91IGFyZSBoYXZpbmcgdHJvdWJsZSB3aXRoIGNsaWNrXG4gICAqIGV2ZW50cy4gUHJlZmVyIHVzaW5nICdoYW5kbGUnIC8gJ2NhbmNlbCcgaW5zdGVhZC5cbiAgICpcbiAgICogRGVmYXVsdHMgdG8gYGZhbHNlYC5cbiAgICovXG4gIGFsbG93TW9iaWxlU2Nyb2xsOiBfcHJvcFR5cGVzLmRlZmF1bHQuYm9vbCxcbiAgY2hpbGRyZW46IF9wcm9wVHlwZXMuZGVmYXVsdC5ub2RlLmlzUmVxdWlyZWQsXG4gIC8qKlxuICAgKiBgZGlzYWJsZWRgLCBpZiB0cnVlLCBzdG9wcyB0aGUgPERyYWdnYWJsZT4gZnJvbSBkcmFnZ2luZy4gQWxsIGhhbmRsZXJzLFxuICAgKiB3aXRoIHRoZSBleGNlcHRpb24gb2YgYG9uTW91c2VEb3duYCwgd2lsbCBub3QgZmlyZS5cbiAgICovXG4gIGRpc2FibGVkOiBfcHJvcFR5cGVzLmRlZmF1bHQuYm9vbCxcbiAgLyoqXG4gICAqIEJ5IGRlZmF1bHQsIHdlIGFkZCAndXNlci1zZWxlY3Q6bm9uZScgYXR0cmlidXRlcyB0byB0aGUgZG9jdW1lbnQgYm9keVxuICAgKiB0byBwcmV2ZW50IHVnbHkgdGV4dCBzZWxlY3Rpb24gZHVyaW5nIGRyYWcuIElmIHRoaXMgaXMgY2F1c2luZyBwcm9ibGVtc1xuICAgKiBmb3IgeW91ciBhcHAsIHNldCB0aGlzIHRvIGBmYWxzZWAuXG4gICAqL1xuICBlbmFibGVVc2VyU2VsZWN0SGFjazogX3Byb3BUeXBlcy5kZWZhdWx0LmJvb2wsXG4gIC8qKlxuICAgKiBgb2Zmc2V0UGFyZW50YCwgaWYgc2V0LCB1c2VzIHRoZSBwYXNzZWQgRE9NIG5vZGUgdG8gY29tcHV0ZSBkcmFnIG9mZnNldHNcbiAgICogaW5zdGVhZCBvZiB1c2luZyB0aGUgcGFyZW50IG5vZGUuXG4gICAqL1xuICBvZmZzZXRQYXJlbnQ6IGZ1bmN0aW9uIChwcm9wcyAvKjogRHJhZ2dhYmxlQ29yZVByb3BzKi8sIHByb3BOYW1lIC8qOiAkS2V5czxEcmFnZ2FibGVDb3JlUHJvcHM+Ki8pIHtcbiAgICBpZiAocHJvcHNbcHJvcE5hbWVdICYmIHByb3BzW3Byb3BOYW1lXS5ub2RlVHlwZSAhPT0gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdEcmFnZ2FibGVcXCdzIG9mZnNldFBhcmVudCBtdXN0IGJlIGEgRE9NIE5vZGUuJyk7XG4gICAgfVxuICB9LFxuICAvKipcbiAgICogYGdyaWRgIHNwZWNpZmllcyB0aGUgeCBhbmQgeSB0aGF0IGRyYWdnaW5nIHNob3VsZCBzbmFwIHRvLlxuICAgKi9cbiAgZ3JpZDogX3Byb3BUeXBlcy5kZWZhdWx0LmFycmF5T2YoX3Byb3BUeXBlcy5kZWZhdWx0Lm51bWJlciksXG4gIC8qKlxuICAgKiBgaGFuZGxlYCBzcGVjaWZpZXMgYSBzZWxlY3RvciB0byBiZSB1c2VkIGFzIHRoZSBoYW5kbGUgdGhhdCBpbml0aWF0ZXMgZHJhZy5cbiAgICpcbiAgICogRXhhbXBsZTpcbiAgICpcbiAgICogYGBganN4XG4gICAqICAgbGV0IEFwcCA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgICogICAgICAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAqICAgICAgICAgcmV0dXJuIChcbiAgICogICAgICAgICAgICA8RHJhZ2dhYmxlIGhhbmRsZT1cIi5oYW5kbGVcIj5cbiAgICogICAgICAgICAgICAgIDxkaXY+XG4gICAqICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJoYW5kbGVcIj5DbGljayBtZSB0byBkcmFnPC9kaXY+XG4gICAqICAgICAgICAgICAgICAgICAgPGRpdj5UaGlzIGlzIHNvbWUgb3RoZXIgY29udGVudDwvZGl2PlxuICAgKiAgICAgICAgICAgICAgPC9kaXY+XG4gICAqICAgICAgICAgICA8L0RyYWdnYWJsZT5cbiAgICogICAgICAgICApO1xuICAgKiAgICAgICB9XG4gICAqICAgfSk7XG4gICAqIGBgYFxuICAgKi9cbiAgaGFuZGxlOiBfcHJvcFR5cGVzLmRlZmF1bHQuc3RyaW5nLFxuICAvKipcbiAgICogYGNhbmNlbGAgc3BlY2lmaWVzIGEgc2VsZWN0b3IgdG8gYmUgdXNlZCB0byBwcmV2ZW50IGRyYWcgaW5pdGlhbGl6YXRpb24uXG4gICAqXG4gICAqIEV4YW1wbGU6XG4gICAqXG4gICAqIGBgYGpzeFxuICAgKiAgIGxldCBBcHAgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gICAqICAgICAgIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICAgKiAgICAgICAgICAgcmV0dXJuKFxuICAgKiAgICAgICAgICAgICAgIDxEcmFnZ2FibGUgY2FuY2VsPVwiLmNhbmNlbFwiPlxuICAgKiAgICAgICAgICAgICAgICAgICA8ZGl2PlxuICAgKiAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY2FuY2VsXCI+WW91IGNhbid0IGRyYWcgZnJvbSBoZXJlPC9kaXY+XG4gICAqICAgICAgICAgICAgICAgICAgICAgPGRpdj5EcmFnZ2luZyBoZXJlIHdvcmtzIGZpbmU8L2Rpdj5cbiAgICogICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAqICAgICAgICAgICAgICAgPC9EcmFnZ2FibGU+XG4gICAqICAgICAgICAgICApO1xuICAgKiAgICAgICB9XG4gICAqICAgfSk7XG4gICAqIGBgYFxuICAgKi9cbiAgY2FuY2VsOiBfcHJvcFR5cGVzLmRlZmF1bHQuc3RyaW5nLFxuICAvKiBJZiBydW5uaW5nIGluIFJlYWN0IFN0cmljdCBtb2RlLCBSZWFjdERPTS5maW5kRE9NTm9kZSgpIGlzIGRlcHJlY2F0ZWQuXG4gICAqIFVuZm9ydHVuYXRlbHksIGluIG9yZGVyIGZvciA8RHJhZ2dhYmxlPiB0byB3b3JrIHByb3Blcmx5LCB3ZSBuZWVkIHJhdyBhY2Nlc3NcbiAgICogdG8gdGhlIHVuZGVybHlpbmcgRE9NIG5vZGUuIElmIHlvdSB3YW50IHRvIGF2b2lkIHRoZSB3YXJuaW5nLCBwYXNzIGEgYG5vZGVSZWZgXG4gICAqIGFzIGluIHRoaXMgZXhhbXBsZTpcbiAgICpcbiAgICogZnVuY3Rpb24gTXlDb21wb25lbnQoKSB7XG4gICAqICAgY29uc3Qgbm9kZVJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgICogICByZXR1cm4gKFxuICAgKiAgICAgPERyYWdnYWJsZSBub2RlUmVmPXtub2RlUmVmfT5cbiAgICogICAgICAgPGRpdiByZWY9e25vZGVSZWZ9PkV4YW1wbGUgVGFyZ2V0PC9kaXY+XG4gICAqICAgICA8L0RyYWdnYWJsZT5cbiAgICogICApO1xuICAgKiB9XG4gICAqXG4gICAqIFRoaXMgY2FuIGJlIHVzZWQgZm9yIGFyYml0cmFyaWx5IG5lc3RlZCBjb21wb25lbnRzLCBzbyBsb25nIGFzIHRoZSByZWYgZW5kcyB1cFxuICAgKiBwb2ludGluZyB0byB0aGUgYWN0dWFsIGNoaWxkIERPTSBub2RlIGFuZCBub3QgYSBjdXN0b20gY29tcG9uZW50LlxuICAgKi9cbiAgbm9kZVJlZjogX3Byb3BUeXBlcy5kZWZhdWx0Lm9iamVjdCxcbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIGRyYWdnaW5nIHN0YXJ0cy5cbiAgICogSWYgdGhpcyBmdW5jdGlvbiByZXR1cm5zIHRoZSBib29sZWFuIGZhbHNlLCBkcmFnZ2luZyB3aWxsIGJlIGNhbmNlbGVkLlxuICAgKi9cbiAgb25TdGFydDogX3Byb3BUeXBlcy5kZWZhdWx0LmZ1bmMsXG4gIC8qKlxuICAgKiBDYWxsZWQgd2hpbGUgZHJhZ2dpbmcuXG4gICAqIElmIHRoaXMgZnVuY3Rpb24gcmV0dXJucyB0aGUgYm9vbGVhbiBmYWxzZSwgZHJhZ2dpbmcgd2lsbCBiZSBjYW5jZWxlZC5cbiAgICovXG4gIG9uRHJhZzogX3Byb3BUeXBlcy5kZWZhdWx0LmZ1bmMsXG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiBkcmFnZ2luZyBzdG9wcy5cbiAgICogSWYgdGhpcyBmdW5jdGlvbiByZXR1cm5zIHRoZSBib29sZWFuIGZhbHNlLCB0aGUgZHJhZyB3aWxsIHJlbWFpbiBhY3RpdmUuXG4gICAqL1xuICBvblN0b3A6IF9wcm9wVHlwZXMuZGVmYXVsdC5mdW5jLFxuICAvKipcbiAgICogQSB3b3JrYXJvdW5kIG9wdGlvbiB3aGljaCBjYW4gYmUgcGFzc2VkIGlmIG9uTW91c2VEb3duIG5lZWRzIHRvIGJlIGFjY2Vzc2VkLFxuICAgKiBzaW5jZSBpdCdsbCBhbHdheXMgYmUgYmxvY2tlZCAoYXMgdGhlcmUgaXMgaW50ZXJuYWwgdXNlIG9mIG9uTW91c2VEb3duKVxuICAgKi9cbiAgb25Nb3VzZURvd246IF9wcm9wVHlwZXMuZGVmYXVsdC5mdW5jLFxuICAvKipcbiAgICogYHNjYWxlYCwgaWYgc2V0LCBhcHBsaWVzIHNjYWxpbmcgd2hpbGUgZHJhZ2dpbmcgYW4gZWxlbWVudFxuICAgKi9cbiAgc2NhbGU6IF9wcm9wVHlwZXMuZGVmYXVsdC5udW1iZXIsXG4gIC8qKlxuICAgKiBUaGVzZSBwcm9wZXJ0aWVzIHNob3VsZCBiZSBkZWZpbmVkIG9uIHRoZSBjaGlsZCwgbm90IGhlcmUuXG4gICAqL1xuICBjbGFzc05hbWU6IF9zaGltcy5kb250U2V0TWUsXG4gIHN0eWxlOiBfc2hpbXMuZG9udFNldE1lLFxuICB0cmFuc2Zvcm06IF9zaGltcy5kb250U2V0TWVcbn0pO1xuX2RlZmluZVByb3BlcnR5KERyYWdnYWJsZUNvcmUsIFwiZGVmYXVsdFByb3BzXCIsIHtcbiAgYWxsb3dBbnlDbGljazogZmFsc2UsXG4gIC8vIGJ5IGRlZmF1bHQgb25seSBhY2NlcHQgbGVmdCBjbGlja1xuICBhbGxvd01vYmlsZVNjcm9sbDogZmFsc2UsXG4gIGRpc2FibGVkOiBmYWxzZSxcbiAgZW5hYmxlVXNlclNlbGVjdEhhY2s6IHRydWUsXG4gIG9uU3RhcnQ6IGZ1bmN0aW9uICgpIHt9LFxuICBvbkRyYWc6IGZ1bmN0aW9uICgpIHt9LFxuICBvblN0b3A6IGZ1bmN0aW9uICgpIHt9LFxuICBvbk1vdXNlRG93bjogZnVuY3Rpb24gKCkge30sXG4gIHNjYWxlOiAxXG59KTsiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJkZWZhdWx0IiwiUmVhY3QiLCJfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZCIsInJlcXVpcmUiLCJfcHJvcFR5cGVzIiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsIl9yZWFjdERvbSIsIl9kb21GbnMiLCJfcG9zaXRpb25GbnMiLCJfc2hpbXMiLCJfbG9nIiwiZSIsIl9fZXNNb2R1bGUiLCJ0IiwiV2Vha01hcCIsInIiLCJuIiwibyIsImkiLCJmIiwiX19wcm90b19fIiwiaGFzIiwiZ2V0Iiwic2V0IiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiX2RlZmluZVByb3BlcnR5IiwiX3RvUHJvcGVydHlLZXkiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJfdG9QcmltaXRpdmUiLCJTeW1ib2wiLCJ0b1ByaW1pdGl2ZSIsIlR5cGVFcnJvciIsIlN0cmluZyIsIk51bWJlciIsImV2ZW50c0ZvciIsInRvdWNoIiwic3RhcnQiLCJtb3ZlIiwic3RvcCIsIm1vdXNlIiwiZHJhZ0V2ZW50Rm9yIiwiRHJhZ2dhYmxlQ29yZSIsIkNvbXBvbmVudCIsImNvbnN0cnVjdG9yIiwiYXJndW1lbnRzIiwiTmFOIiwicHJvcHMiLCJvbk1vdXNlRG93biIsImFsbG93QW55Q2xpY2siLCJidXR0b24iLCJ0aGlzTm9kZSIsImZpbmRET01Ob2RlIiwib3duZXJEb2N1bWVudCIsImJvZHkiLCJFcnJvciIsImRpc2FibGVkIiwidGFyZ2V0IiwiZGVmYXVsdFZpZXciLCJOb2RlIiwiaGFuZGxlIiwibWF0Y2hlc1NlbGVjdG9yQW5kUGFyZW50c1RvIiwiY2FuY2VsIiwidHlwZSIsImFsbG93TW9iaWxlU2Nyb2xsIiwicHJldmVudERlZmF1bHQiLCJ0b3VjaElkZW50aWZpZXIiLCJnZXRUb3VjaElkZW50aWZpZXIiLCJwb3NpdGlvbiIsImdldENvbnRyb2xQb3NpdGlvbiIsIngiLCJ5IiwiY29yZUV2ZW50IiwiY3JlYXRlQ29yZURhdGEiLCJvblN0YXJ0Iiwic2hvdWxkVXBkYXRlIiwibW91bnRlZCIsImVuYWJsZVVzZXJTZWxlY3RIYWNrIiwiYWRkVXNlclNlbGVjdFN0eWxlcyIsImRyYWdnaW5nIiwibGFzdFgiLCJsYXN0WSIsImFkZEV2ZW50IiwiaGFuZGxlRHJhZyIsImhhbmRsZURyYWdTdG9wIiwiQXJyYXkiLCJpc0FycmF5IiwiZ3JpZCIsImRlbHRhWCIsImRlbHRhWSIsInNuYXBUb0dyaWQiLCJvbkRyYWciLCJNb3VzZUV2ZW50IiwiZXJyIiwiZXZlbnQiLCJkb2N1bWVudCIsImNyZWF0ZUV2ZW50IiwiaW5pdE1vdXNlRXZlbnQiLCJ3aW5kb3ciLCJzaG91bGRDb250aW51ZSIsIm9uU3RvcCIsInNjaGVkdWxlUmVtb3ZlVXNlclNlbGVjdFN0eWxlcyIsInJlbW92ZUV2ZW50IiwiaGFuZGxlRHJhZ1N0YXJ0IiwiY29tcG9uZW50RGlkTW91bnQiLCJvblRvdWNoU3RhcnQiLCJwYXNzaXZlIiwiY29tcG9uZW50V2lsbFVubW91bnQiLCJub2RlUmVmIiwiY3VycmVudCIsInJlbmRlciIsImNsb25lRWxlbWVudCIsIkNoaWxkcmVuIiwib25seSIsImNoaWxkcmVuIiwib25Nb3VzZVVwIiwib25Ub3VjaEVuZCIsImJvb2wiLCJub2RlIiwiaXNSZXF1aXJlZCIsIm9mZnNldFBhcmVudCIsInByb3BOYW1lIiwibm9kZVR5cGUiLCJhcnJheU9mIiwibnVtYmVyIiwic3RyaW5nIiwib2JqZWN0IiwiZnVuYyIsInNjYWxlIiwiY2xhc3NOYW1lIiwiZG9udFNldE1lIiwic3R5bGUiLCJ0cmFuc2Zvcm0iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-draggable/build/cjs/DraggableCore.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-draggable/build/cjs/cjs.js":
/*!*******************************************************!*\
  !*** ./node_modules/react-draggable/build/cjs/cjs.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { default: Draggable, DraggableCore } = __webpack_require__(/*! ./Draggable */ \"(ssr)/./node_modules/react-draggable/build/cjs/Draggable.js\");\n// Previous versions of this lib exported <Draggable> as the root export. As to no-// them, or TypeScript, we export *both* as the root and as 'default'.\n// See https://github.com/mzabriskie/react-draggable/pull/254\n// and https://github.com/mzabriskie/react-draggable/issues/266\nmodule.exports = Draggable;\nmodule.exports[\"default\"] = Draggable;\nmodule.exports.DraggableCore = DraggableCore;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtZHJhZ2dhYmxlL2J1aWxkL2Nqcy9janMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYixNQUFNLEVBQ0pBLFNBQVNDLFNBQVMsRUFDbEJDLGFBQWEsRUFDZCxHQUFHQyxtQkFBT0EsQ0FBQztBQUVaLHlKQUF5SjtBQUN6Siw2REFBNkQ7QUFDN0QsK0RBQStEO0FBQy9EQyxPQUFPQyxPQUFPLEdBQUdKO0FBQ2pCRyx5QkFBc0IsR0FBR0g7QUFDekJHLDRCQUE0QixHQUFHRiIsInNvdXJjZXMiOlsid2VicGFjazovL2FpLW9zLW12cC8uL25vZGVfbW9kdWxlcy9yZWFjdC1kcmFnZ2FibGUvYnVpbGQvY2pzL2Nqcy5qcz83NzYwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5jb25zdCB7XG4gIGRlZmF1bHQ6IERyYWdnYWJsZSxcbiAgRHJhZ2dhYmxlQ29yZVxufSA9IHJlcXVpcmUoJy4vRHJhZ2dhYmxlJyk7XG5cbi8vIFByZXZpb3VzIHZlcnNpb25zIG9mIHRoaXMgbGliIGV4cG9ydGVkIDxEcmFnZ2FibGU+IGFzIHRoZSByb290IGV4cG9ydC4gQXMgdG8gbm8tLy8gdGhlbSwgb3IgVHlwZVNjcmlwdCwgd2UgZXhwb3J0ICpib3RoKiBhcyB0aGUgcm9vdCBhbmQgYXMgJ2RlZmF1bHQnLlxuLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9temFicmlza2llL3JlYWN0LWRyYWdnYWJsZS9wdWxsLzI1NFxuLy8gYW5kIGh0dHBzOi8vZ2l0aHViLmNvbS9temFicmlza2llL3JlYWN0LWRyYWdnYWJsZS9pc3N1ZXMvMjY2XG5tb2R1bGUuZXhwb3J0cyA9IERyYWdnYWJsZTtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBEcmFnZ2FibGU7XG5tb2R1bGUuZXhwb3J0cy5EcmFnZ2FibGVDb3JlID0gRHJhZ2dhYmxlQ29yZTsiXSwibmFtZXMiOlsiZGVmYXVsdCIsIkRyYWdnYWJsZSIsIkRyYWdnYWJsZUNvcmUiLCJyZXF1aXJlIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-draggable/build/cjs/cjs.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-draggable/build/cjs/utils/domFns.js":
/*!****************************************************************!*\
  !*** ./node_modules/react-draggable/build/cjs/utils/domFns.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.addClassName = addClassName;\nexports.addEvent = addEvent;\nexports.addUserSelectStyles = addUserSelectStyles;\nexports.createCSSTransform = createCSSTransform;\nexports.createSVGTransform = createSVGTransform;\nexports.getTouch = getTouch;\nexports.getTouchIdentifier = getTouchIdentifier;\nexports.getTranslation = getTranslation;\nexports.innerHeight = innerHeight;\nexports.innerWidth = innerWidth;\nexports.matchesSelector = matchesSelector;\nexports.matchesSelectorAndParentsTo = matchesSelectorAndParentsTo;\nexports.offsetXYFromParent = offsetXYFromParent;\nexports.outerHeight = outerHeight;\nexports.outerWidth = outerWidth;\nexports.removeClassName = removeClassName;\nexports.removeEvent = removeEvent;\nexports.scheduleRemoveUserSelectStyles = scheduleRemoveUserSelectStyles;\nvar _shims = __webpack_require__(/*! ./shims */ \"(ssr)/./node_modules/react-draggable/build/cjs/utils/shims.js\");\nvar _getPrefix = _interopRequireWildcard(__webpack_require__(/*! ./getPrefix */ \"(ssr)/./node_modules/react-draggable/build/cjs/utils/getPrefix.js\"));\nfunction _interopRequireWildcard(e, t) {\n    if (\"function\" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap();\n    return (_interopRequireWildcard = function(e, t) {\n        if (!t && e && e.__esModule) return e;\n        var o, i, f = {\n            __proto__: null,\n            default: e\n        };\n        if (null === e || \"object\" != typeof e && \"function\" != typeof e) return f;\n        if (o = t ? n : r) {\n            if (o.has(e)) return o.get(e);\n            o.set(e, f);\n        }\n        for(const t in e)\"default\" !== t && ({}).hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]);\n        return f;\n    })(e, t);\n}\n/*:: import type {ControlPosition, PositionOffsetControlPosition, MouseTouchEvent} from './types';*/ let matchesSelectorFunc = \"\";\nfunction matchesSelector(el /*: Node*/ , selector /*: string*/ ) /*: boolean*/ {\n    if (!matchesSelectorFunc) {\n        matchesSelectorFunc = (0, _shims.findInArray)([\n            \"matches\",\n            \"webkitMatchesSelector\",\n            \"mozMatchesSelector\",\n            \"msMatchesSelector\",\n            \"oMatchesSelector\"\n        ], function(method) {\n            // $FlowIgnore: Doesn't think elements are indexable\n            return (0, _shims.isFunction)(el[method]);\n        });\n    }\n    // Might not be found entirely (not an Element?) - in that case, bail\n    // $FlowIgnore: Doesn't think elements are indexable\n    if (!(0, _shims.isFunction)(el[matchesSelectorFunc])) return false;\n    // $FlowIgnore: Doesn't think elements are indexable\n    return el[matchesSelectorFunc](selector);\n}\n// Works up the tree to the draggable itself attempting to match selector.\nfunction matchesSelectorAndParentsTo(el /*: Node*/ , selector /*: string*/ , baseNode /*: Node*/ ) /*: boolean*/ {\n    let node = el;\n    do {\n        if (matchesSelector(node, selector)) return true;\n        if (node === baseNode) return false;\n        // $FlowIgnore[incompatible-type]\n        node = node.parentNode;\n    }while (node);\n    return false;\n}\nfunction addEvent(el /*: ?Node*/ , event /*: string*/ , handler /*: Function*/ , inputOptions /*: Object*/ ) /*: void*/ {\n    if (!el) return;\n    const options = {\n        capture: true,\n        ...inputOptions\n    };\n    // $FlowIgnore[method-unbinding]\n    if (el.addEventListener) {\n        el.addEventListener(event, handler, options);\n    } else if (el.attachEvent) {\n        el.attachEvent(\"on\" + event, handler);\n    } else {\n        // $FlowIgnore: Doesn't think elements are indexable\n        el[\"on\" + event] = handler;\n    }\n}\nfunction removeEvent(el /*: ?Node*/ , event /*: string*/ , handler /*: Function*/ , inputOptions /*: Object*/ ) /*: void*/ {\n    if (!el) return;\n    const options = {\n        capture: true,\n        ...inputOptions\n    };\n    // $FlowIgnore[method-unbinding]\n    if (el.removeEventListener) {\n        el.removeEventListener(event, handler, options);\n    } else if (el.detachEvent) {\n        el.detachEvent(\"on\" + event, handler);\n    } else {\n        // $FlowIgnore: Doesn't think elements are indexable\n        el[\"on\" + event] = null;\n    }\n}\nfunction outerHeight(node /*: HTMLElement*/ ) /*: number*/ {\n    // This is deliberately excluding margin for our calculations, since we are using\n    // offsetTop which is including margin. See getBoundPosition\n    let height = node.clientHeight;\n    const computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);\n    height += (0, _shims.int)(computedStyle.borderTopWidth);\n    height += (0, _shims.int)(computedStyle.borderBottomWidth);\n    return height;\n}\nfunction outerWidth(node /*: HTMLElement*/ ) /*: number*/ {\n    // This is deliberately excluding margin for our calculations, since we are using\n    // offsetLeft which is including margin. See getBoundPosition\n    let width = node.clientWidth;\n    const computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);\n    width += (0, _shims.int)(computedStyle.borderLeftWidth);\n    width += (0, _shims.int)(computedStyle.borderRightWidth);\n    return width;\n}\nfunction innerHeight(node /*: HTMLElement*/ ) /*: number*/ {\n    let height = node.clientHeight;\n    const computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);\n    height -= (0, _shims.int)(computedStyle.paddingTop);\n    height -= (0, _shims.int)(computedStyle.paddingBottom);\n    return height;\n}\nfunction innerWidth(node /*: HTMLElement*/ ) /*: number*/ {\n    let width = node.clientWidth;\n    const computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);\n    width -= (0, _shims.int)(computedStyle.paddingLeft);\n    width -= (0, _shims.int)(computedStyle.paddingRight);\n    return width;\n}\n/*:: interface EventWithOffset {\n  clientX: number, clientY: number\n}*/ // Get from offsetParent\nfunction offsetXYFromParent(evt /*: EventWithOffset*/ , offsetParent /*: HTMLElement*/ , scale /*: number*/ ) /*: ControlPosition*/ {\n    const isBody = offsetParent === offsetParent.ownerDocument.body;\n    const offsetParentRect = isBody ? {\n        left: 0,\n        top: 0\n    } : offsetParent.getBoundingClientRect();\n    const x = (evt.clientX + offsetParent.scrollLeft - offsetParentRect.left) / scale;\n    const y = (evt.clientY + offsetParent.scrollTop - offsetParentRect.top) / scale;\n    return {\n        x,\n        y\n    };\n}\nfunction createCSSTransform(controlPos /*: ControlPosition*/ , positionOffset /*: PositionOffsetControlPosition*/ ) /*: Object*/ {\n    const translation = getTranslation(controlPos, positionOffset, \"px\");\n    return {\n        [(0, _getPrefix.browserPrefixToKey)(\"transform\", _getPrefix.default)]: translation\n    };\n}\nfunction createSVGTransform(controlPos /*: ControlPosition*/ , positionOffset /*: PositionOffsetControlPosition*/ ) /*: string*/ {\n    const translation = getTranslation(controlPos, positionOffset, \"\");\n    return translation;\n}\nfunction getTranslation(_ref /*:: */ , positionOffset /*: PositionOffsetControlPosition*/ , unitSuffix /*: string*/ ) /*: string*/ {\n    let { x, y } /*: ControlPosition*/  = _ref /*: ControlPosition*/ ;\n    let translation = `translate(${x}${unitSuffix},${y}${unitSuffix})`;\n    if (positionOffset) {\n        const defaultX = `${typeof positionOffset.x === \"string\" ? positionOffset.x : positionOffset.x + unitSuffix}`;\n        const defaultY = `${typeof positionOffset.y === \"string\" ? positionOffset.y : positionOffset.y + unitSuffix}`;\n        translation = `translate(${defaultX}, ${defaultY})` + translation;\n    }\n    return translation;\n}\nfunction getTouch(e /*: MouseTouchEvent*/ , identifier /*: number*/ ) /*: ?{clientX: number, clientY: number}*/ {\n    return e.targetTouches && (0, _shims.findInArray)(e.targetTouches, (t)=>identifier === t.identifier) || e.changedTouches && (0, _shims.findInArray)(e.changedTouches, (t)=>identifier === t.identifier);\n}\nfunction getTouchIdentifier(e /*: MouseTouchEvent*/ ) /*: ?number*/ {\n    if (e.targetTouches && e.targetTouches[0]) return e.targetTouches[0].identifier;\n    if (e.changedTouches && e.changedTouches[0]) return e.changedTouches[0].identifier;\n}\n// User-select Hacks:\n//\n// Useful for preventing blue highlights all over everything when dragging.\n// Note we're passing `document` b/c we could be iframed\nfunction addUserSelectStyles(doc /*: ?Document*/ ) {\n    if (!doc) return;\n    let styleEl = doc.getElementById(\"react-draggable-style-el\");\n    if (!styleEl) {\n        styleEl = doc.createElement(\"style\");\n        styleEl.type = \"text/css\";\n        styleEl.id = \"react-draggable-style-el\";\n        styleEl.innerHTML = \".react-draggable-transparent-selection *::-moz-selection {all: inherit;}\\n\";\n        styleEl.innerHTML += \".react-draggable-transparent-selection *::selection {all: inherit;}\\n\";\n        doc.getElementsByTagName(\"head\")[0].appendChild(styleEl);\n    }\n    if (doc.body) addClassName(doc.body, \"react-draggable-transparent-selection\");\n}\nfunction scheduleRemoveUserSelectStyles(doc /*: ?Document*/ ) {\n    // Prevent a possible \"forced reflow\"\n    if (window.requestAnimationFrame) {\n        window.requestAnimationFrame(()=>{\n            removeUserSelectStyles(doc);\n        });\n    } else {\n        removeUserSelectStyles(doc);\n    }\n}\nfunction removeUserSelectStyles(doc /*: ?Document*/ ) {\n    if (!doc) return;\n    try {\n        if (doc.body) removeClassName(doc.body, \"react-draggable-transparent-selection\");\n        // $FlowIgnore: IE\n        if (doc.selection) {\n            // $FlowIgnore: IE\n            doc.selection.empty();\n        } else {\n            // Remove selection caused by scroll, unless it's a focused input\n            // (we use doc.defaultView in case we're in an iframe)\n            const selection = (doc.defaultView || window).getSelection();\n            if (selection && selection.type !== \"Caret\") {\n                selection.removeAllRanges();\n            }\n        }\n    } catch (e) {\n    // probably IE\n    }\n}\nfunction addClassName(el /*: HTMLElement*/ , className /*: string*/ ) {\n    if (el.classList) {\n        el.classList.add(className);\n    } else {\n        if (!el.className.match(new RegExp(`(?:^|\\\\s)${className}(?!\\\\S)`))) {\n            el.className += ` ${className}`;\n        }\n    }\n}\nfunction removeClassName(el /*: HTMLElement*/ , className /*: string*/ ) {\n    if (el.classList) {\n        el.classList.remove(className);\n    } else {\n        el.className = el.className.replace(new RegExp(`(?:^|\\\\s)${className}(?!\\\\S)`, \"g\"), \"\");\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtZHJhZ2dhYmxlL2J1aWxkL2Nqcy91dGlscy9kb21GbnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYkEsOENBQTZDO0lBQzNDRyxPQUFPO0FBQ1QsQ0FBQyxFQUFDO0FBQ0ZELG9CQUFvQixHQUFHRTtBQUN2QkYsZ0JBQWdCLEdBQUdHO0FBQ25CSCwyQkFBMkIsR0FBR0k7QUFDOUJKLDBCQUEwQixHQUFHSztBQUM3QkwsMEJBQTBCLEdBQUdNO0FBQzdCTixnQkFBZ0IsR0FBR087QUFDbkJQLDBCQUEwQixHQUFHUTtBQUM3QlIsc0JBQXNCLEdBQUdTO0FBQ3pCVCxtQkFBbUIsR0FBR1U7QUFDdEJWLGtCQUFrQixHQUFHVztBQUNyQlgsdUJBQXVCLEdBQUdZO0FBQzFCWixtQ0FBbUMsR0FBR2E7QUFDdENiLDBCQUEwQixHQUFHYztBQUM3QmQsbUJBQW1CLEdBQUdlO0FBQ3RCZixrQkFBa0IsR0FBR2dCO0FBQ3JCaEIsdUJBQXVCLEdBQUdpQjtBQUMxQmpCLG1CQUFtQixHQUFHa0I7QUFDdEJsQixzQ0FBc0MsR0FBR21CO0FBQ3pDLElBQUlDLFNBQVNDLG1CQUFPQSxDQUFDLDhFQUFTO0FBQzlCLElBQUlDLGFBQWFDLHdCQUF3QkYsbUJBQU9BLENBQUMsc0ZBQWE7QUFDOUQsU0FBU0Usd0JBQXdCQyxDQUFDLEVBQUVDLENBQUM7SUFBSSxJQUFJLGNBQWMsT0FBT0MsU0FBUyxJQUFJQyxJQUFJLElBQUlELFdBQVdFLElBQUksSUFBSUY7SUFBVyxPQUFPLENBQUNILDBCQUEwQixTQUFVQyxDQUFDLEVBQUVDLENBQUM7UUFBSSxJQUFJLENBQUNBLEtBQUtELEtBQUtBLEVBQUVLLFVBQVUsRUFBRSxPQUFPTDtRQUFHLElBQUlNLEdBQUdDLEdBQUdDLElBQUk7WUFBRUMsV0FBVztZQUFNQyxTQUFTVjtRQUFFO1FBQUcsSUFBSSxTQUFTQSxLQUFLLFlBQVksT0FBT0EsS0FBSyxjQUFjLE9BQU9BLEdBQUcsT0FBT1E7UUFBRyxJ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NUUsR0FBRzRFLFNBQVMsR0FBRzVFLEdBQUc0RSxTQUFTLENBQUNNLE9BQU8sQ0FBQyxJQUFJRixPQUFPLENBQUMsU0FBUyxFQUFFSixVQUFVLE9BQU8sQ0FBQyxFQUFFLE1BQU07SUFDdkY7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL2FpLW9zLW12cC8uL25vZGVfbW9kdWxlcy9yZWFjdC1kcmFnZ2FibGUvYnVpbGQvY2pzL3V0aWxzL2RvbUZucy5qcz8zOWE2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5hZGRDbGFzc05hbWUgPSBhZGRDbGFzc05hbWU7XG5leHBvcnRzLmFkZEV2ZW50ID0gYWRkRXZlbnQ7XG5leHBvcnRzLmFkZFVzZXJTZWxlY3RTdHlsZXMgPSBhZGRVc2VyU2VsZWN0U3R5bGVzO1xuZXhwb3J0cy5jcmVhdGVDU1NUcmFuc2Zvcm0gPSBjcmVhdGVDU1NUcmFuc2Zvcm07XG5leHBvcnRzLmNyZWF0ZVNWR1RyYW5zZm9ybSA9IGNyZWF0ZVNWR1RyYW5zZm9ybTtcbmV4cG9ydHMuZ2V0VG91Y2ggPSBnZXRUb3VjaDtcbmV4cG9ydHMuZ2V0VG91Y2hJZGVudGlmaWVyID0gZ2V0VG91Y2hJZGVudGlmaWVyO1xuZXhwb3J0cy5nZXRUcmFuc2xhdGlvbiA9IGdldFRyYW5zbGF0aW9uO1xuZXhwb3J0cy5pbm5lckhlaWdodCA9IGlubmVySGVpZ2h0O1xuZXhwb3J0cy5pbm5lcldpZHRoID0gaW5uZXJXaWR0aDtcbmV4cG9ydHMubWF0Y2hlc1NlbGVjdG9yID0gbWF0Y2hlc1NlbGVjdG9yO1xuZXhwb3J0cy5tYXRjaGVzU2VsZWN0b3JBbmRQYXJlbnRzVG8gPSBtYXRjaGVzU2VsZWN0b3JBbmRQYXJlbnRzVG87XG5leHBvcnRzLm9mZnNldFhZRnJvbVBhcmVudCA9IG9mZnNldFhZRnJvbVBhcmVudDtcbmV4cG9ydHMub3V0ZXJIZWlnaHQgPSBvdXRlckhlaWdodDtcbmV4cG9ydHMub3V0ZXJXaWR0aCA9IG91dGVyV2lkdGg7XG5leHBvcnRzLnJlbW92ZUNsYXNzTmFtZSA9IHJlbW92ZUNsYXNzTmFtZTtcbmV4cG9ydHMucmVtb3ZlRXZlbnQgPSByZW1vdmVFdmVudDtcbmV4cG9ydHMuc2NoZWR1bGVSZW1vdmVVc2VyU2VsZWN0U3R5bGVzID0gc2NoZWR1bGVSZW1vdmVVc2VyU2VsZWN0U3R5bGVzO1xudmFyIF9zaGltcyA9IHJlcXVpcmUoXCIuL3NoaW1zXCIpO1xudmFyIF9nZXRQcmVmaXggPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi9nZXRQcmVmaXhcIikpO1xuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoZSwgdCkgeyBpZiAoXCJmdW5jdGlvblwiID09IHR5cGVvZiBXZWFrTWFwKSB2YXIgciA9IG5ldyBXZWFrTWFwKCksIG4gPSBuZXcgV2Vha01hcCgpOyByZXR1cm4gKF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkID0gZnVuY3Rpb24gKGUsIHQpIHsgaWYgKCF0ICYmIGUgJiYgZS5fX2VzTW9kdWxlKSByZXR1cm4gZTsgdmFyIG8sIGksIGYgPSB7IF9fcHJvdG9fXzogbnVsbCwgZGVmYXVsdDogZSB9OyBpZiAobnVsbCA9PT0gZSB8fCBcIm9iamVjdFwiICE9IHR5cGVvZiBlICYmIFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgZSkgcmV0dXJuIGY7IGlmIChvID0gdCA/IG4gOiByKSB7IGlmIChvLmhhcyhlKSkgcmV0dXJuIG8uZ2V0KGUpOyBvLnNldChlLCBmKTsgfSBmb3IgKGNvbnN0IHQgaW4gZSkgXCJkZWZhdWx0XCIgIT09IHQgJiYge30uaGFzT3duUHJvcGVydHkuY2FsbChlLCB0KSAmJiAoKGkgPSAobyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCB0KSkgJiYgKGkuZ2V0IHx8IGkuc2V0KSA/IG8oZiwgdCwgaSkgOiBmW3RdID0gZVt0XSk7IHJldHVybiBmOyB9KShlLCB0KTsgfVxuLyo6OiBpbXBvcnQgdHlwZSB7Q29udHJvbFBvc2l0aW9uLCBQb3NpdGlvbk9mZnNldENvbnRyb2xQb3NpdGlvbiwgTW91c2VUb3VjaEV2ZW50fSBmcm9tICcuL3R5cGVzJzsqL1xubGV0IG1hdGNoZXNTZWxlY3RvckZ1bmMgPSAnJztcbmZ1bmN0aW9uIG1hdGNoZXNTZWxlY3RvcihlbCAvKjogTm9kZSovLCBzZWxlY3RvciAvKjogc3RyaW5nKi8pIC8qOiBib29sZWFuKi97XG4gIGlmICghbWF0Y2hlc1NlbGVjdG9yRnVuYykge1xuICAgIG1hdGNoZXNTZWxlY3RvckZ1bmMgPSAoMCwgX3NoaW1zLmZpbmRJbkFycmF5KShbJ21hdGNoZXMnLCAnd2Via2l0TWF0Y2hlc1NlbGVjdG9yJywgJ21vek1hdGNoZXNTZWxlY3RvcicsICdtc01hdGNoZXNTZWxlY3RvcicsICdvTWF0Y2hlc1NlbGVjdG9yJ10sIGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgIC8vICRGbG93SWdub3JlOiBEb2Vzbid0IHRoaW5rIGVsZW1lbnRzIGFyZSBpbmRleGFibGVcbiAgICAgIHJldHVybiAoMCwgX3NoaW1zLmlzRnVuY3Rpb24pKGVsW21ldGhvZF0pO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gTWlnaHQgbm90IGJlIGZvdW5kIGVudGlyZWx5IChub3QgYW4gRWxlbWVudD8pIC0gaW4gdGhhdCBjYXNlLCBiYWlsXG4gIC8vICRGbG93SWdub3JlOiBEb2Vzbid0IHRoaW5rIGVsZW1lbnRzIGFyZSBpbmRleGFibGVcbiAgaWYgKCEoMCwgX3NoaW1zLmlzRnVuY3Rpb24pKGVsW21hdGNoZXNTZWxlY3RvckZ1bmNdKSkgcmV0dXJuIGZhbHNlO1xuXG4gIC8vICRGbG93SWdub3JlOiBEb2Vzbid0IHRoaW5rIGVsZW1lbnRzIGFyZSBpbmRleGFibGVcbiAgcmV0dXJuIGVsW21hdGNoZXNTZWxlY3RvckZ1bmNdKHNlbGVjdG9yKTtcbn1cblxuLy8gV29ya3MgdXAgdGhlIHRyZWUgdG8gdGhlIGRyYWdnYWJsZSBpdHNlbGYgYXR0ZW1wdGluZyB0byBtYXRjaCBzZWxlY3Rvci5cbmZ1bmN0aW9uIG1hdGNoZXNTZWxlY3RvckFuZFBhcmVudHNUbyhlbCAvKjogTm9kZSovLCBzZWxlY3RvciAvKjogc3RyaW5nKi8sIGJhc2VOb2RlIC8qOiBOb2RlKi8pIC8qOiBib29sZWFuKi97XG4gIGxldCBub2RlID0gZWw7XG4gIGRvIHtcbiAgICBpZiAobWF0Y2hlc1NlbGVjdG9yKG5vZGUsIHNlbGVjdG9yKSkgcmV0dXJuIHRydWU7XG4gICAgaWYgKG5vZGUgPT09IGJhc2VOb2RlKSByZXR1cm4gZmFsc2U7XG4gICAgLy8gJEZsb3dJZ25vcmVbaW5jb21wYXRpYmxlLXR5cGVdXG4gICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgfSB3aGlsZSAobm9kZSk7XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGFkZEV2ZW50KGVsIC8qOiA/Tm9kZSovLCBldmVudCAvKjogc3RyaW5nKi8sIGhhbmRsZXIgLyo6IEZ1bmN0aW9uKi8sIGlucHV0T3B0aW9ucyAvKjogT2JqZWN0Ki8pIC8qOiB2b2lkKi97XG4gIGlmICghZWwpIHJldHVybjtcbiAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICBjYXB0dXJlOiB0cnVlLFxuICAgIC4uLmlucHV0T3B0aW9uc1xuICB9O1xuICAvLyAkRmxvd0lnbm9yZVttZXRob2QtdW5iaW5kaW5nXVxuICBpZiAoZWwuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpO1xuICB9IGVsc2UgaWYgKGVsLmF0dGFjaEV2ZW50KSB7XG4gICAgZWwuYXR0YWNoRXZlbnQoJ29uJyArIGV2ZW50LCBoYW5kbGVyKTtcbiAgfSBlbHNlIHtcbiAgICAvLyAkRmxvd0lnbm9yZTogRG9lc24ndCB0aGluayBlbGVtZW50cyBhcmUgaW5kZXhhYmxlXG4gICAgZWxbJ29uJyArIGV2ZW50XSA9IGhhbmRsZXI7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlbW92ZUV2ZW50KGVsIC8qOiA/Tm9kZSovLCBldmVudCAvKjogc3RyaW5nKi8sIGhhbmRsZXIgLyo6IEZ1bmN0aW9uKi8sIGlucHV0T3B0aW9ucyAvKjogT2JqZWN0Ki8pIC8qOiB2b2lkKi97XG4gIGlmICghZWwpIHJldHVybjtcbiAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICBjYXB0dXJlOiB0cnVlLFxuICAgIC4uLmlucHV0T3B0aW9uc1xuICB9O1xuICAvLyAkRmxvd0lnbm9yZVttZXRob2QtdW5iaW5kaW5nXVxuICBpZiAoZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcikge1xuICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpO1xuICB9IGVsc2UgaWYgKGVsLmRldGFjaEV2ZW50KSB7XG4gICAgZWwuZGV0YWNoRXZlbnQoJ29uJyArIGV2ZW50LCBoYW5kbGVyKTtcbiAgfSBlbHNlIHtcbiAgICAvLyAkRmxvd0lnbm9yZTogRG9lc24ndCB0aGluayBlbGVtZW50cyBhcmUgaW5kZXhhYmxlXG4gICAgZWxbJ29uJyArIGV2ZW50XSA9IG51bGw7XG4gIH1cbn1cbmZ1bmN0aW9uIG91dGVySGVpZ2h0KG5vZGUgLyo6IEhUTUxFbGVtZW50Ki8pIC8qOiBudW1iZXIqL3tcbiAgLy8gVGhpcyBpcyBkZWxpYmVyYXRlbHkgZXhjbHVkaW5nIG1hcmdpbiBmb3Igb3VyIGNhbGN1bGF0aW9ucywgc2luY2Ugd2UgYXJlIHVzaW5nXG4gIC8vIG9mZnNldFRvcCB3aGljaCBpcyBpbmNsdWRpbmcgbWFyZ2luLiBTZWUgZ2V0Qm91bmRQb3NpdGlvblxuICBsZXQgaGVpZ2h0ID0gbm9kZS5jbGllbnRIZWlnaHQ7XG4gIGNvbnN0IGNvbXB1dGVkU3R5bGUgPSBub2RlLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcbiAgaGVpZ2h0ICs9ICgwLCBfc2hpbXMuaW50KShjb21wdXRlZFN0eWxlLmJvcmRlclRvcFdpZHRoKTtcbiAgaGVpZ2h0ICs9ICgwLCBfc2hpbXMuaW50KShjb21wdXRlZFN0eWxlLmJvcmRlckJvdHRvbVdpZHRoKTtcbiAgcmV0dXJuIGhlaWdodDtcbn1cbmZ1bmN0aW9uIG91dGVyV2lkdGgobm9kZSAvKjogSFRNTEVsZW1lbnQqLykgLyo6IG51bWJlciove1xuICAvLyBUaGlzIGlzIGRlbGliZXJhdGVseSBleGNsdWRpbmcgbWFyZ2luIGZvciBvdXIgY2FsY3VsYXRpb25zLCBzaW5jZSB3ZSBhcmUgdXNpbmdcbiAgLy8gb2Zmc2V0TGVmdCB3aGljaCBpcyBpbmNsdWRpbmcgbWFyZ2luLiBTZWUgZ2V0Qm91bmRQb3NpdGlvblxuICBsZXQgd2lkdGggPSBub2RlLmNsaWVudFdpZHRoO1xuICBjb25zdCBjb21wdXRlZFN0eWxlID0gbm9kZS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUobm9kZSk7XG4gIHdpZHRoICs9ICgwLCBfc2hpbXMuaW50KShjb21wdXRlZFN0eWxlLmJvcmRlckxlZnRXaWR0aCk7XG4gIHdpZHRoICs9ICgwLCBfc2hpbXMuaW50KShjb21wdXRlZFN0eWxlLmJvcmRlclJpZ2h0V2lkdGgpO1xuICByZXR1cm4gd2lkdGg7XG59XG5mdW5jdGlvbiBpbm5lckhlaWdodChub2RlIC8qOiBIVE1MRWxlbWVudCovKSAvKjogbnVtYmVyKi97XG4gIGxldCBoZWlnaHQgPSBub2RlLmNsaWVudEhlaWdodDtcbiAgY29uc3QgY29tcHV0ZWRTdHlsZSA9IG5vZGUub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuICBoZWlnaHQgLT0gKDAsIF9zaGltcy5pbnQpKGNvbXB1dGVkU3R5bGUucGFkZGluZ1RvcCk7XG4gIGhlaWdodCAtPSAoMCwgX3NoaW1zLmludCkoY29tcHV0ZWRTdHlsZS5wYWRkaW5nQm90dG9tKTtcbiAgcmV0dXJuIGhlaWdodDtcbn1cbmZ1bmN0aW9uIGlubmVyV2lkdGgobm9kZSAvKjogSFRNTEVsZW1lbnQqLykgLyo6IG51bWJlciove1xuICBsZXQgd2lkdGggPSBub2RlLmNsaWVudFdpZHRoO1xuICBjb25zdCBjb21wdXRlZFN0eWxlID0gbm9kZS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUobm9kZSk7XG4gIHdpZHRoIC09ICgwLCBfc2hpbXMuaW50KShjb21wdXRlZFN0eWxlLnBhZGRpbmdMZWZ0KTtcbiAgd2lkdGggLT0gKDAsIF9zaGltcy5pbnQpKGNvbXB1dGVkU3R5bGUucGFkZGluZ1JpZ2h0KTtcbiAgcmV0dXJuIHdpZHRoO1xufVxuLyo6OiBpbnRlcmZhY2UgRXZlbnRXaXRoT2Zmc2V0IHtcbiAgY2xpZW50WDogbnVtYmVyLCBjbGllbnRZOiBudW1iZXJcbn0qL1xuLy8gR2V0IGZyb20gb2Zmc2V0UGFyZW50XG5mdW5jdGlvbiBvZmZzZXRYWUZyb21QYXJlbnQoZXZ0IC8qOiBFdmVudFdpdGhPZmZzZXQqLywgb2Zmc2V0UGFyZW50IC8qOiBIVE1MRWxlbWVudCovLCBzY2FsZSAvKjogbnVtYmVyKi8pIC8qOiBDb250cm9sUG9zaXRpb24qL3tcbiAgY29uc3QgaXNCb2R5ID0gb2Zmc2V0UGFyZW50ID09PSBvZmZzZXRQYXJlbnQub3duZXJEb2N1bWVudC5ib2R5O1xuICBjb25zdCBvZmZzZXRQYXJlbnRSZWN0ID0gaXNCb2R5ID8ge1xuICAgIGxlZnQ6IDAsXG4gICAgdG9wOiAwXG4gIH0gOiBvZmZzZXRQYXJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIGNvbnN0IHggPSAoZXZ0LmNsaWVudFggKyBvZmZzZXRQYXJlbnQuc2Nyb2xsTGVmdCAtIG9mZnNldFBhcmVudFJlY3QubGVmdCkgLyBzY2FsZTtcbiAgY29uc3QgeSA9IChldnQuY2xpZW50WSArIG9mZnNldFBhcmVudC5zY3JvbGxUb3AgLSBvZmZzZXRQYXJlbnRSZWN0LnRvcCkgLyBzY2FsZTtcbiAgcmV0dXJuIHtcbiAgICB4LFxuICAgIHlcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNTU1RyYW5zZm9ybShjb250cm9sUG9zIC8qOiBDb250cm9sUG9zaXRpb24qLywgcG9zaXRpb25PZmZzZXQgLyo6IFBvc2l0aW9uT2Zmc2V0Q29udHJvbFBvc2l0aW9uKi8pIC8qOiBPYmplY3QqL3tcbiAgY29uc3QgdHJhbnNsYXRpb24gPSBnZXRUcmFuc2xhdGlvbihjb250cm9sUG9zLCBwb3NpdGlvbk9mZnNldCwgJ3B4Jyk7XG4gIHJldHVybiB7XG4gICAgWygwLCBfZ2V0UHJlZml4LmJyb3dzZXJQcmVmaXhUb0tleSkoJ3RyYW5zZm9ybScsIF9nZXRQcmVmaXguZGVmYXVsdCldOiB0cmFuc2xhdGlvblxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlU1ZHVHJhbnNmb3JtKGNvbnRyb2xQb3MgLyo6IENvbnRyb2xQb3NpdGlvbiovLCBwb3NpdGlvbk9mZnNldCAvKjogUG9zaXRpb25PZmZzZXRDb250cm9sUG9zaXRpb24qLykgLyo6IHN0cmluZyove1xuICBjb25zdCB0cmFuc2xhdGlvbiA9IGdldFRyYW5zbGF0aW9uKGNvbnRyb2xQb3MsIHBvc2l0aW9uT2Zmc2V0LCAnJyk7XG4gIHJldHVybiB0cmFuc2xhdGlvbjtcbn1cbmZ1bmN0aW9uIGdldFRyYW5zbGF0aW9uKF9yZWYgLyo6OiAqLywgcG9zaXRpb25PZmZzZXQgLyo6IFBvc2l0aW9uT2Zmc2V0Q29udHJvbFBvc2l0aW9uKi8sIHVuaXRTdWZmaXggLyo6IHN0cmluZyovKSAvKjogc3RyaW5nKi97XG4gIGxldCB7XG4gICAgeCxcbiAgICB5XG4gIH0gLyo6IENvbnRyb2xQb3NpdGlvbiovID0gX3JlZiAvKjogQ29udHJvbFBvc2l0aW9uKi87XG4gIGxldCB0cmFuc2xhdGlvbiA9IGB0cmFuc2xhdGUoJHt4fSR7dW5pdFN1ZmZpeH0sJHt5fSR7dW5pdFN1ZmZpeH0pYDtcbiAgaWYgKHBvc2l0aW9uT2Zmc2V0KSB7XG4gICAgY29uc3QgZGVmYXVsdFggPSBgJHt0eXBlb2YgcG9zaXRpb25PZmZzZXQueCA9PT0gJ3N0cmluZycgPyBwb3NpdGlvbk9mZnNldC54IDogcG9zaXRpb25PZmZzZXQueCArIHVuaXRTdWZmaXh9YDtcbiAgICBjb25zdCBkZWZhdWx0WSA9IGAke3R5cGVvZiBwb3NpdGlvbk9mZnNldC55ID09PSAnc3RyaW5nJyA/IHBvc2l0aW9uT2Zmc2V0LnkgOiBwb3NpdGlvbk9mZnNldC55ICsgdW5pdFN1ZmZpeH1gO1xuICAgIHRyYW5zbGF0aW9uID0gYHRyYW5zbGF0ZSgke2RlZmF1bHRYfSwgJHtkZWZhdWx0WX0pYCArIHRyYW5zbGF0aW9uO1xuICB9XG4gIHJldHVybiB0cmFuc2xhdGlvbjtcbn1cbmZ1bmN0aW9uIGdldFRvdWNoKGUgLyo6IE1vdXNlVG91Y2hFdmVudCovLCBpZGVudGlmaWVyIC8qOiBudW1iZXIqLykgLyo6ID97Y2xpZW50WDogbnVtYmVyLCBjbGllbnRZOiBudW1iZXJ9Ki97XG4gIHJldHVybiBlLnRhcmdldFRvdWNoZXMgJiYgKDAsIF9zaGltcy5maW5kSW5BcnJheSkoZS50YXJnZXRUb3VjaGVzLCB0ID0+IGlkZW50aWZpZXIgPT09IHQuaWRlbnRpZmllcikgfHwgZS5jaGFuZ2VkVG91Y2hlcyAmJiAoMCwgX3NoaW1zLmZpbmRJbkFycmF5KShlLmNoYW5nZWRUb3VjaGVzLCB0ID0+IGlkZW50aWZpZXIgPT09IHQuaWRlbnRpZmllcik7XG59XG5mdW5jdGlvbiBnZXRUb3VjaElkZW50aWZpZXIoZSAvKjogTW91c2VUb3VjaEV2ZW50Ki8pIC8qOiA/bnVtYmVyKi97XG4gIGlmIChlLnRhcmdldFRvdWNoZXMgJiYgZS50YXJnZXRUb3VjaGVzWzBdKSByZXR1cm4gZS50YXJnZXRUb3VjaGVzWzBdLmlkZW50aWZpZXI7XG4gIGlmIChlLmNoYW5nZWRUb3VjaGVzICYmIGUuY2hhbmdlZFRvdWNoZXNbMF0pIHJldHVybiBlLmNoYW5nZWRUb3VjaGVzWzBdLmlkZW50aWZpZXI7XG59XG5cbi8vIFVzZXItc2VsZWN0IEhhY2tzOlxuLy9cbi8vIFVzZWZ1bCBmb3IgcHJldmVudGluZyBibHVlIGhpZ2hsaWdodHMgYWxsIG92ZXIgZXZlcnl0aGluZyB3aGVuIGRyYWdnaW5nLlxuXG4vLyBOb3RlIHdlJ3JlIHBhc3NpbmcgYGRvY3VtZW50YCBiL2Mgd2UgY291bGQgYmUgaWZyYW1lZFxuZnVuY3Rpb24gYWRkVXNlclNlbGVjdFN0eWxlcyhkb2MgLyo6ID9Eb2N1bWVudCovKSB7XG4gIGlmICghZG9jKSByZXR1cm47XG4gIGxldCBzdHlsZUVsID0gZG9jLmdldEVsZW1lbnRCeUlkKCdyZWFjdC1kcmFnZ2FibGUtc3R5bGUtZWwnKTtcbiAgaWYgKCFzdHlsZUVsKSB7XG4gICAgc3R5bGVFbCA9IGRvYy5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgIHN0eWxlRWwudHlwZSA9ICd0ZXh0L2Nzcyc7XG4gICAgc3R5bGVFbC5pZCA9ICdyZWFjdC1kcmFnZ2FibGUtc3R5bGUtZWwnO1xuICAgIHN0eWxlRWwuaW5uZXJIVE1MID0gJy5yZWFjdC1kcmFnZ2FibGUtdHJhbnNwYXJlbnQtc2VsZWN0aW9uICo6Oi1tb3otc2VsZWN0aW9uIHthbGw6IGluaGVyaXQ7fVxcbic7XG4gICAgc3R5bGVFbC5pbm5lckhUTUwgKz0gJy5yZWFjdC1kcmFnZ2FibGUtdHJhbnNwYXJlbnQtc2VsZWN0aW9uICo6OnNlbGVjdGlvbiB7YWxsOiBpbmhlcml0O31cXG4nO1xuICAgIGRvYy5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdLmFwcGVuZENoaWxkKHN0eWxlRWwpO1xuICB9XG4gIGlmIChkb2MuYm9keSkgYWRkQ2xhc3NOYW1lKGRvYy5ib2R5LCAncmVhY3QtZHJhZ2dhYmxlLXRyYW5zcGFyZW50LXNlbGVjdGlvbicpO1xufVxuZnVuY3Rpb24gc2NoZWR1bGVSZW1vdmVVc2VyU2VsZWN0U3R5bGVzKGRvYyAvKjogP0RvY3VtZW50Ki8pIHtcbiAgLy8gUHJldmVudCBhIHBvc3NpYmxlIFwiZm9yY2VkIHJlZmxvd1wiXG4gIGlmICh3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB7XG4gICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICByZW1vdmVVc2VyU2VsZWN0U3R5bGVzKGRvYyk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgcmVtb3ZlVXNlclNlbGVjdFN0eWxlcyhkb2MpO1xuICB9XG59XG5mdW5jdGlvbiByZW1vdmVVc2VyU2VsZWN0U3R5bGVzKGRvYyAvKjogP0RvY3VtZW50Ki8pIHtcbiAgaWYgKCFkb2MpIHJldHVybjtcbiAgdHJ5IHtcbiAgICBpZiAoZG9jLmJvZHkpIHJlbW92ZUNsYXNzTmFtZShkb2MuYm9keSwgJ3JlYWN0LWRyYWdnYWJsZS10cmFuc3BhcmVudC1zZWxlY3Rpb24nKTtcbiAgICAvLyAkRmxvd0lnbm9yZTogSUVcbiAgICBpZiAoZG9jLnNlbGVjdGlvbikge1xuICAgICAgLy8gJEZsb3dJZ25vcmU6IElFXG4gICAgICBkb2Muc2VsZWN0aW9uLmVtcHR5KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlbW92ZSBzZWxlY3Rpb24gY2F1c2VkIGJ5IHNjcm9sbCwgdW5sZXNzIGl0J3MgYSBmb2N1c2VkIGlucHV0XG4gICAgICAvLyAod2UgdXNlIGRvYy5kZWZhdWx0VmlldyBpbiBjYXNlIHdlJ3JlIGluIGFuIGlmcmFtZSlcbiAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IChkb2MuZGVmYXVsdFZpZXcgfHwgd2luZG93KS5nZXRTZWxlY3Rpb24oKTtcbiAgICAgIGlmIChzZWxlY3Rpb24gJiYgc2VsZWN0aW9uLnR5cGUgIT09ICdDYXJldCcpIHtcbiAgICAgICAgc2VsZWN0aW9uLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIHByb2JhYmx5IElFXG4gIH1cbn1cbmZ1bmN0aW9uIGFkZENsYXNzTmFtZShlbCAvKjogSFRNTEVsZW1lbnQqLywgY2xhc3NOYW1lIC8qOiBzdHJpbmcqLykge1xuICBpZiAoZWwuY2xhc3NMaXN0KSB7XG4gICAgZWwuY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpO1xuICB9IGVsc2Uge1xuICAgIGlmICghZWwuY2xhc3NOYW1lLm1hdGNoKG5ldyBSZWdFeHAoYCg/Ol58XFxcXHMpJHtjbGFzc05hbWV9KD8hXFxcXFMpYCkpKSB7XG4gICAgICBlbC5jbGFzc05hbWUgKz0gYCAke2NsYXNzTmFtZX1gO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gcmVtb3ZlQ2xhc3NOYW1lKGVsIC8qOiBIVE1MRWxlbWVudCovLCBjbGFzc05hbWUgLyo6IHN0cmluZyovKSB7XG4gIGlmIChlbC5jbGFzc0xpc3QpIHtcbiAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSk7XG4gIH0gZWxzZSB7XG4gICAgZWwuY2xhc3NOYW1lID0gZWwuY2xhc3NOYW1lLnJlcGxhY2UobmV3IFJlZ0V4cChgKD86XnxcXFxccykke2NsYXNzTmFtZX0oPyFcXFxcUylgLCAnZycpLCAnJyk7XG4gIH1cbn0iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJhZGRDbGFzc05hbWUiLCJhZGRFdmVudCIsImFkZFVzZXJTZWxlY3RTdHlsZXMiLCJjcmVhdGVDU1NUcmFuc2Zvcm0iLCJjcmVhdGVTVkdUcmFuc2Zvcm0iLCJnZXRUb3VjaCIsImdldFRvdWNoSWRlbnRpZmllciIsImdldFRyYW5zbGF0aW9uIiwiaW5uZXJIZWlnaHQiLCJpbm5lcldpZHRoIiwibWF0Y2hlc1NlbGVjdG9yIiwibWF0Y2hlc1NlbGVjdG9yQW5kUGFyZW50c1RvIiwib2Zmc2V0WFlGcm9tUGFyZW50Iiwib3V0ZXJIZWlnaHQiLCJvdXRlcldpZHRoIiwicmVtb3ZlQ2xhc3NOYW1lIiwicmVtb3ZlRXZlbnQiLCJzY2hlZHVsZVJlbW92ZVVzZXJTZWxlY3RTdHlsZXMiLCJfc2hpbXMiLCJyZXF1aXJlIiwiX2dldFByZWZpeCIsIl9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkIiwiZSIsInQiLCJXZWFrTWFwIiwiciIsIm4iLCJfX2VzTW9kdWxlIiwibyIsImkiLCJmIiwiX19wcm90b19fIiwiZGVmYXVsdCIsImhhcyIsImdldCIsInNldCIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIm1hdGNoZXNTZWxlY3RvckZ1bmMiLCJlbCIsInNlbGVjdG9yIiwiZmluZEluQXJyYXkiLCJtZXRob2QiLCJpc0Z1bmN0aW9uIiwiYmFzZU5vZGUiLCJub2RlIiwicGFyZW50Tm9kZSIsImV2ZW50IiwiaGFuZGxlciIsImlucHV0T3B0aW9ucyIsIm9wdGlvbnMiLCJjYXB0dXJlIiwiYWRkRXZlbnRMaXN0ZW5lciIsImF0dGFjaEV2ZW50IiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImRldGFjaEV2ZW50IiwiaGVpZ2h0IiwiY2xpZW50SGVpZ2h0IiwiY29tcHV0ZWRTdHlsZSIsIm93bmVyRG9jdW1lbnQiLCJkZWZhdWx0VmlldyIsImdldENvbXB1dGVkU3R5bGUiLCJpbnQiLCJib3JkZXJUb3BXaWR0aCIsImJvcmRlckJvdHRvbVdpZHRoIiwid2lkdGgiLCJjbGllbnRXaWR0aCIsImJvcmRlckxlZnRXaWR0aCIsImJvcmRlclJpZ2h0V2lkdGgiLCJwYWRkaW5nVG9wIiwicGFkZGluZ0JvdHRvbSIsInBhZGRpbmdMZWZ0IiwicGFkZGluZ1JpZ2h0IiwiZXZ0Iiwib2Zmc2V0UGFyZW50Iiwic2NhbGUiLCJpc0JvZHkiLCJib2R5Iiwib2Zmc2V0UGFyZW50UmVjdCIsImxlZnQiLCJ0b3AiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJ4IiwiY2xpZW50WCIsInNjcm9sbExlZnQiLCJ5IiwiY2xpZW50WSIsInNjcm9sbFRvcCIsImNvbnRyb2xQb3MiLCJwb3NpdGlvbk9mZnNldCIsInRyYW5zbGF0aW9uIiwiYnJvd3NlclByZWZpeFRvS2V5IiwiX3JlZiIsInVuaXRTdWZmaXgiLCJkZWZhdWx0WCIsImRlZmF1bHRZIiwiaWRlbnRpZmllciIsInRhcmdldFRvdWNoZXMiLCJjaGFuZ2VkVG91Y2hlcyIsImRvYyIsInN0eWxlRWwiLCJnZXRFbGVtZW50QnlJZCIsImNyZWF0ZUVsZW1lbnQiLCJ0eXBlIiwiaWQiLCJpbm5lckhUTUwiLCJnZXRFbGVtZW50c0J5VGFnTmFtZSIsImFwcGVuZENoaWxkIiwid2luZG93IiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwicmVtb3ZlVXNlclNlbGVjdFN0eWxlcyIsInNlbGVjdGlvbiIsImVtcHR5IiwiZ2V0U2VsZWN0aW9uIiwicmVtb3ZlQWxsUmFuZ2VzIiwiY2xhc3NOYW1lIiwiY2xhc3NMaXN0IiwiYWRkIiwibWF0Y2giLCJSZWdFeHAiLCJyZW1vdmUiLCJyZXBsYWNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-draggable/build/cjs/utils/domFns.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-draggable/build/cjs/utils/getPrefix.js":
/*!*******************************************************************!*\
  !*** ./node_modules/react-draggable/build/cjs/utils/getPrefix.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.browserPrefixToKey = browserPrefixToKey;\nexports.browserPrefixToStyle = browserPrefixToStyle;\nexports[\"default\"] = void 0;\nexports.getPrefix = getPrefix;\nconst prefixes = [\n    \"Moz\",\n    \"Webkit\",\n    \"O\",\n    \"ms\"\n];\nfunction getPrefix() /*: string*/ {\n    let prop /*: string*/  = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"transform\";\n    // Ensure we're running in an environment where there is actually a global\n    // `window` obj\n    if (true) return \"\";\n    // If we're in a pseudo-browser server-side environment, this access\n    // path may not exist, so bail out if it doesn't.\n    const style = window.document?.documentElement?.style;\n    if (!style) return \"\";\n    if (prop in style) return \"\";\n    for(let i = 0; i < prefixes.length; i++){\n        if (browserPrefixToKey(prop, prefixes[i]) in style) return prefixes[i];\n    }\n    return \"\";\n}\nfunction browserPrefixToKey(prop /*: string*/ , prefix /*: string*/ ) /*: string*/ {\n    return prefix ? `${prefix}${kebabToTitleCase(prop)}` : prop;\n}\nfunction browserPrefixToStyle(prop /*: string*/ , prefix /*: string*/ ) /*: string*/ {\n    return prefix ? `-${prefix.toLowerCase()}-${prop}` : prop;\n}\nfunction kebabToTitleCase(str /*: string*/ ) /*: string*/ {\n    let out = \"\";\n    let shouldCapitalize = true;\n    for(let i = 0; i < str.length; i++){\n        if (shouldCapitalize) {\n            out += str[i].toUpperCase();\n            shouldCapitalize = false;\n        } else if (str[i] === \"-\") {\n            shouldCapitalize = true;\n        } else {\n            out += str[i];\n        }\n    }\n    return out;\n}\n// Default export is the prefix itself, like 'Moz', 'Webkit', etc\n// Note that you may have to re-test for certain things; for instance, Chrome 50\n// can handle unprefixed `transform`, but not unprefixed `user-select`\nvar _default = exports[\"default\"] = getPrefix();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtZHJhZ2dhYmxlL2J1aWxkL2Nqcy91dGlscy9nZXRQcmVmaXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYkEsOENBQTZDO0lBQzNDRyxPQUFPO0FBQ1QsQ0FBQyxFQUFDO0FBQ0ZELDBCQUEwQixHQUFHRTtBQUM3QkYsNEJBQTRCLEdBQUdHO0FBQy9CSCxrQkFBZSxHQUFHLEtBQUs7QUFDdkJBLGlCQUFpQixHQUFHSztBQUNwQixNQUFNQyxXQUFXO0lBQUM7SUFBTztJQUFVO0lBQUs7Q0FBSztBQUM3QyxTQUFTRCxZQUFZLFVBQVU7SUFDN0IsSUFBSUUsS0FBSyxVQUFVLE1BQUtDLFVBQVVDLE1BQU0sR0FBRyxLQUFLRCxTQUFTLENBQUMsRUFBRSxLQUFLRSxZQUFZRixTQUFTLENBQUMsRUFBRSxHQUFHO0lBQzVGLDBFQUEwRTtJQUMxRSxlQUFlO0lBQ2YsSUFBSSxJQUFrQixFQUFhLE9BQU87SUFFMUMsb0VBQW9FO0lBQ3BFLGlEQUFpRDtJQUNqRCxNQUFNRyxRQUFRQyxPQUFPQyxRQUFRLEVBQUVDLGlCQUFpQkg7SUFDaEQsSUFBSSxDQUFDQSxPQUFPLE9BQU87SUFDbkIsSUFBSUosUUFBUUksT0FBTyxPQUFPO0lBQzFCLElBQUssSUFBSUksSUFBSSxHQUFHQSxJQUFJVCxTQUFTRyxNQUFNLEVBQUVNLElBQUs7UUFDeEMsSUFBSWIsbUJBQW1CSyxNQUFNRCxRQUFRLENBQUNTLEVBQUUsS0FBS0osT0FBTyxPQUFPTCxRQUFRLENBQUNTLEVBQUU7SUFDeEU7SUFDQSxPQUFPO0FBQ1Q7QUFDQSxTQUFTYixtQkFBbUJLLEtBQUssVUFBVSxHQUFYLEVBQWVTLE9BQU8sVUFBVSxHQUFYLEVBQWUsVUFBVTtJQUM1RSxPQUFPQSxTQUFTLENBQUMsRUFBRUEsT0FBTyxFQUFFQyxpQkFBaUJWLE1BQU0sQ0FBQyxHQUFHQTtBQUN6RDtBQUNBLFNBQVNKLHFCQUFxQkksS0FBSyxVQUFVLEdBQVgsRUFBZVMsT0FBTyxVQUFVLEdBQVgsRUFBZSxVQUFVO0lBQzlFLE9BQU9BLFNBQVMsQ0FBQyxDQUFDLEVBQUVBLE9BQU9FLFdBQVcsR0FBRyxDQUFDLEVBQUVYLEtBQUssQ0FBQyxHQUFHQTtBQUN2RDtBQUNBLFNBQVNVLGlCQUFpQkUsSUFBSSxVQUFVLEdBQVgsRUFBZSxVQUFVO0lBQ3BELElBQUlDLE1BQU07SUFDVixJQUFJQyxtQkFBbUI7SUFDdkIsSUFBSyxJQUFJTixJQUFJLEdBQUdBLElBQUlJLElBQUlWLE1BQU0sRUFBRU0sSUFBSztRQUNuQyxJQUFJTSxrQkFBa0I7WUFDcEJELE9BQU9ELEdBQUcsQ0FBQ0osRUFBRSxDQUFDTyxXQUFXO1lBQ3pCRCxtQkFBbUI7UUFDckIsT0FBTyxJQUFJRixHQUFHLENBQUNKLEVBQUUsS0FBSyxLQUFLO1lBQ3pCTSxtQkFBbUI7UUFDckIsT0FBTztZQUNMRCxPQUFPRCxHQUFHLENBQUNKLEVBQUU7UUFDZjtJQUNGO0lBQ0EsT0FBT0s7QUFDVDtBQUVBLGlFQUFpRTtBQUNqRSxnRkFBZ0Y7QUFDaEYsc0VBQXNFO0FBQ3RFLElBQUlHLFdBQVd2QixrQkFBZSxHQUFJSyIsInNvdXJjZXMiOlsid2VicGFjazovL2FpLW9zLW12cC8uL25vZGVfbW9kdWxlcy9yZWFjdC1kcmFnZ2FibGUvYnVpbGQvY2pzL3V0aWxzL2dldFByZWZpeC5qcz80NGEzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5icm93c2VyUHJlZml4VG9LZXkgPSBicm93c2VyUHJlZml4VG9LZXk7XG5leHBvcnRzLmJyb3dzZXJQcmVmaXhUb1N0eWxlID0gYnJvd3NlclByZWZpeFRvU3R5bGU7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5leHBvcnRzLmdldFByZWZpeCA9IGdldFByZWZpeDtcbmNvbnN0IHByZWZpeGVzID0gWydNb3onLCAnV2Via2l0JywgJ08nLCAnbXMnXTtcbmZ1bmN0aW9uIGdldFByZWZpeCgpIC8qOiBzdHJpbmcqL3tcbiAgbGV0IHByb3AgLyo6IHN0cmluZyovID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAndHJhbnNmb3JtJztcbiAgLy8gRW5zdXJlIHdlJ3JlIHJ1bm5pbmcgaW4gYW4gZW52aXJvbm1lbnQgd2hlcmUgdGhlcmUgaXMgYWN0dWFsbHkgYSBnbG9iYWxcbiAgLy8gYHdpbmRvd2Agb2JqXG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuICcnO1xuXG4gIC8vIElmIHdlJ3JlIGluIGEgcHNldWRvLWJyb3dzZXIgc2VydmVyLXNpZGUgZW52aXJvbm1lbnQsIHRoaXMgYWNjZXNzXG4gIC8vIHBhdGggbWF5IG5vdCBleGlzdCwgc28gYmFpbCBvdXQgaWYgaXQgZG9lc24ndC5cbiAgY29uc3Qgc3R5bGUgPSB3aW5kb3cuZG9jdW1lbnQ/LmRvY3VtZW50RWxlbWVudD8uc3R5bGU7XG4gIGlmICghc3R5bGUpIHJldHVybiAnJztcbiAgaWYgKHByb3AgaW4gc3R5bGUpIHJldHVybiAnJztcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmVmaXhlcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChicm93c2VyUHJlZml4VG9LZXkocHJvcCwgcHJlZml4ZXNbaV0pIGluIHN0eWxlKSByZXR1cm4gcHJlZml4ZXNbaV07XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuZnVuY3Rpb24gYnJvd3NlclByZWZpeFRvS2V5KHByb3AgLyo6IHN0cmluZyovLCBwcmVmaXggLyo6IHN0cmluZyovKSAvKjogc3RyaW5nKi97XG4gIHJldHVybiBwcmVmaXggPyBgJHtwcmVmaXh9JHtrZWJhYlRvVGl0bGVDYXNlKHByb3ApfWAgOiBwcm9wO1xufVxuZnVuY3Rpb24gYnJvd3NlclByZWZpeFRvU3R5bGUocHJvcCAvKjogc3RyaW5nKi8sIHByZWZpeCAvKjogc3RyaW5nKi8pIC8qOiBzdHJpbmcqL3tcbiAgcmV0dXJuIHByZWZpeCA/IGAtJHtwcmVmaXgudG9Mb3dlckNhc2UoKX0tJHtwcm9wfWAgOiBwcm9wO1xufVxuZnVuY3Rpb24ga2ViYWJUb1RpdGxlQ2FzZShzdHIgLyo6IHN0cmluZyovKSAvKjogc3RyaW5nKi97XG4gIGxldCBvdXQgPSAnJztcbiAgbGV0IHNob3VsZENhcGl0YWxpemUgPSB0cnVlO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIGlmIChzaG91bGRDYXBpdGFsaXplKSB7XG4gICAgICBvdXQgKz0gc3RyW2ldLnRvVXBwZXJDYXNlKCk7XG4gICAgICBzaG91bGRDYXBpdGFsaXplID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChzdHJbaV0gPT09ICctJykge1xuICAgICAgc2hvdWxkQ2FwaXRhbGl6ZSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dCArPSBzdHJbaV07XG4gICAgfVxuICB9XG4gIHJldHVybiBvdXQ7XG59XG5cbi8vIERlZmF1bHQgZXhwb3J0IGlzIHRoZSBwcmVmaXggaXRzZWxmLCBsaWtlICdNb3onLCAnV2Via2l0JywgZXRjXG4vLyBOb3RlIHRoYXQgeW91IG1heSBoYXZlIHRvIHJlLXRlc3QgZm9yIGNlcnRhaW4gdGhpbmdzOyBmb3IgaW5zdGFuY2UsIENocm9tZSA1MFxuLy8gY2FuIGhhbmRsZSB1bnByZWZpeGVkIGB0cmFuc2Zvcm1gLCBidXQgbm90IHVucHJlZml4ZWQgYHVzZXItc2VsZWN0YFxudmFyIF9kZWZhdWx0ID0gZXhwb3J0cy5kZWZhdWx0ID0gKGdldFByZWZpeCgpIC8qOiBzdHJpbmcqLyk7Il0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiYnJvd3NlclByZWZpeFRvS2V5IiwiYnJvd3NlclByZWZpeFRvU3R5bGUiLCJkZWZhdWx0IiwiZ2V0UHJlZml4IiwicHJlZml4ZXMiLCJwcm9wIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwidW5kZWZpbmVkIiwic3R5bGUiLCJ3aW5kb3ciLCJkb2N1bWVudCIsImRvY3VtZW50RWxlbWVudCIsImkiLCJwcmVmaXgiLCJrZWJhYlRvVGl0bGVDYXNlIiwidG9Mb3dlckNhc2UiLCJzdHIiLCJvdXQiLCJzaG91bGRDYXBpdGFsaXplIiwidG9VcHBlckNhc2UiLCJfZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-draggable/build/cjs/utils/getPrefix.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-draggable/build/cjs/utils/log.js":
/*!*************************************************************!*\
  !*** ./node_modules/react-draggable/build/cjs/utils/log.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports[\"default\"] = log;\n/*eslint no-console:0*/ function log() {\n    if (false) {}\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtZHJhZ2dhYmxlL2J1aWxkL2Nqcy91dGlscy9sb2cuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYkEsOENBQTZDO0lBQzNDRyxPQUFPO0FBQ1QsQ0FBQyxFQUFDO0FBQ0ZELGtCQUFlLEdBQUdHO0FBQ2xCLHFCQUFxQixHQUNyQixTQUFTQTtJQUNQLElBQUlDLEtBQVNBLEVBQUVDLEVBQTBCQztBQUMzQyIsInNvdXJjZXMiOlsid2VicGFjazovL2FpLW9zLW12cC8uL25vZGVfbW9kdWxlcy9yZWFjdC1kcmFnZ2FibGUvYnVpbGQvY2pzL3V0aWxzL2xvZy5qcz9lMDYzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gbG9nO1xuLyplc2xpbnQgbm8tY29uc29sZTowKi9cbmZ1bmN0aW9uIGxvZygpIHtcbiAgaWYgKHVuZGVmaW5lZCkgY29uc29sZS5sb2coLi4uYXJndW1lbnRzKTtcbn0iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJkZWZhdWx0IiwibG9nIiwidW5kZWZpbmVkIiwiY29uc29sZSIsImFyZ3VtZW50cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-draggable/build/cjs/utils/log.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-draggable/build/cjs/utils/positionFns.js":
/*!*********************************************************************!*\
  !*** ./node_modules/react-draggable/build/cjs/utils/positionFns.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.canDragX = canDragX;\nexports.canDragY = canDragY;\nexports.createCoreData = createCoreData;\nexports.createDraggableData = createDraggableData;\nexports.getBoundPosition = getBoundPosition;\nexports.getControlPosition = getControlPosition;\nexports.snapToGrid = snapToGrid;\nvar _shims = __webpack_require__(/*! ./shims */ \"(ssr)/./node_modules/react-draggable/build/cjs/utils/shims.js\");\nvar _domFns = __webpack_require__(/*! ./domFns */ \"(ssr)/./node_modules/react-draggable/build/cjs/utils/domFns.js\");\n/*:: import type Draggable from '../Draggable';*/ /*:: import type {Bounds, ControlPosition, DraggableData, MouseTouchEvent} from './types';*/ /*:: import type DraggableCore from '../DraggableCore';*/ function getBoundPosition(draggable /*: Draggable*/ , x /*: number*/ , y /*: number*/ ) /*: [number, number]*/ {\n    // If no bounds, short-circuit and move on\n    if (!draggable.props.bounds) return [\n        x,\n        y\n    ];\n    // Clone new bounds\n    let { bounds } = draggable.props;\n    bounds = typeof bounds === \"string\" ? bounds : cloneBounds(bounds);\n    const node = findDOMNode(draggable);\n    if (typeof bounds === \"string\") {\n        const { ownerDocument } = node;\n        const ownerWindow = ownerDocument.defaultView;\n        let boundNode;\n        if (bounds === \"parent\") {\n            boundNode = node.parentNode;\n        } else {\n            // Flow assigns the wrong return type (Node) for getRootNode(),\n            // so we cast it to one of the correct types (Element).\n            // The others are Document and ShadowRoot.\n            // All three implement querySelector() so it's safe to call.\n            const rootNode = node.getRootNode();\n            boundNode = rootNode.querySelector(bounds);\n        }\n        if (!(boundNode instanceof ownerWindow.HTMLElement)) {\n            throw new Error('Bounds selector \"' + bounds + '\" could not find an element.');\n        }\n        const boundNodeEl /*: HTMLElement*/  = boundNode; // for Flow, can't seem to refine correctly\n        const nodeStyle = ownerWindow.getComputedStyle(node);\n        const boundNodeStyle = ownerWindow.getComputedStyle(boundNodeEl);\n        // Compute bounds. This is a pain with padding and offsets but this gets it exactly right.\n        bounds = {\n            left: -node.offsetLeft + (0, _shims.int)(boundNodeStyle.paddingLeft) + (0, _shims.int)(nodeStyle.marginLeft),\n            top: -node.offsetTop + (0, _shims.int)(boundNodeStyle.paddingTop) + (0, _shims.int)(nodeStyle.marginTop),\n            right: (0, _domFns.innerWidth)(boundNodeEl) - (0, _domFns.outerWidth)(node) - node.offsetLeft + (0, _shims.int)(boundNodeStyle.paddingRight) - (0, _shims.int)(nodeStyle.marginRight),\n            bottom: (0, _domFns.innerHeight)(boundNodeEl) - (0, _domFns.outerHeight)(node) - node.offsetTop + (0, _shims.int)(boundNodeStyle.paddingBottom) - (0, _shims.int)(nodeStyle.marginBottom)\n        };\n    }\n    // Keep x and y below right and bottom limits...\n    if ((0, _shims.isNum)(bounds.right)) x = Math.min(x, bounds.right);\n    if ((0, _shims.isNum)(bounds.bottom)) y = Math.min(y, bounds.bottom);\n    // But above left and top limits.\n    if ((0, _shims.isNum)(bounds.left)) x = Math.max(x, bounds.left);\n    if ((0, _shims.isNum)(bounds.top)) y = Math.max(y, bounds.top);\n    return [\n        x,\n        y\n    ];\n}\nfunction snapToGrid(grid /*: [number, number]*/ , pendingX /*: number*/ , pendingY /*: number*/ ) /*: [number, number]*/ {\n    const x = Math.round(pendingX / grid[0]) * grid[0];\n    const y = Math.round(pendingY / grid[1]) * grid[1];\n    return [\n        x,\n        y\n    ];\n}\nfunction canDragX(draggable /*: Draggable*/ ) /*: boolean*/ {\n    return draggable.props.axis === \"both\" || draggable.props.axis === \"x\";\n}\nfunction canDragY(draggable /*: Draggable*/ ) /*: boolean*/ {\n    return draggable.props.axis === \"both\" || draggable.props.axis === \"y\";\n}\n// Get {x, y} positions from event.\nfunction getControlPosition(e /*: MouseTouchEvent*/ , touchIdentifier /*: ?number*/ , draggableCore /*: DraggableCore*/ ) /*: ?ControlPosition*/ {\n    const touchObj = typeof touchIdentifier === \"number\" ? (0, _domFns.getTouch)(e, touchIdentifier) : null;\n    if (typeof touchIdentifier === \"number\" && !touchObj) return null; // not the right touch\n    const node = findDOMNode(draggableCore);\n    // User can provide an offsetParent if desired.\n    const offsetParent = draggableCore.props.offsetParent || node.offsetParent || node.ownerDocument.body;\n    return (0, _domFns.offsetXYFromParent)(touchObj || e, offsetParent, draggableCore.props.scale);\n}\n// Create an data object exposed by <DraggableCore>'s events\nfunction createCoreData(draggable /*: DraggableCore*/ , x /*: number*/ , y /*: number*/ ) /*: DraggableData*/ {\n    const isStart = !(0, _shims.isNum)(draggable.lastX);\n    const node = findDOMNode(draggable);\n    if (isStart) {\n        // If this is our first move, use the x and y as last coords.\n        return {\n            node,\n            deltaX: 0,\n            deltaY: 0,\n            lastX: x,\n            lastY: y,\n            x,\n            y\n        };\n    } else {\n        // Otherwise calculate proper values.\n        return {\n            node,\n            deltaX: x - draggable.lastX,\n            deltaY: y - draggable.lastY,\n            lastX: draggable.lastX,\n            lastY: draggable.lastY,\n            x,\n            y\n        };\n    }\n}\n// Create an data exposed by <Draggable>'s events\nfunction createDraggableData(draggable /*: Draggable*/ , coreData /*: DraggableData*/ ) /*: DraggableData*/ {\n    const scale = draggable.props.scale;\n    return {\n        node: coreData.node,\n        x: draggable.state.x + coreData.deltaX / scale,\n        y: draggable.state.y + coreData.deltaY / scale,\n        deltaX: coreData.deltaX / scale,\n        deltaY: coreData.deltaY / scale,\n        lastX: draggable.state.x,\n        lastY: draggable.state.y\n    };\n}\n// A lot faster than stringify/parse\nfunction cloneBounds(bounds /*: Bounds*/ ) /*: Bounds*/ {\n    return {\n        left: bounds.left,\n        top: bounds.top,\n        right: bounds.right,\n        bottom: bounds.bottom\n    };\n}\nfunction findDOMNode(draggable /*: Draggable | DraggableCore*/ ) /*: HTMLElement*/ {\n    const node = draggable.findDOMNode();\n    if (!node) {\n        throw new Error(\"<DraggableCore>: Unmounted during event!\");\n    }\n    // $FlowIgnore we can't assert on HTMLElement due to tests... FIXME\n    return node;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtZHJhZ2dhYmxlL2J1aWxkL2Nqcy91dGlscy9wb3NpdGlvbkZucy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViQSw4Q0FBNkM7SUFDM0NHLE9BQU87QUFDVCxDQUFDLEVBQUM7QUFDRkQsZ0JBQWdCLEdBQUdFO0FBQ25CRixnQkFBZ0IsR0FBR0c7QUFDbkJILHNCQUFzQixHQUFHSTtBQUN6QkosMkJBQTJCLEdBQUdLO0FBQzlCTCx3QkFBd0IsR0FBR007QUFDM0JOLDBCQUEwQixHQUFHTztBQUM3QlAsa0JBQWtCLEdBQUdRO0FBQ3JCLElBQUlDLFNBQVNDLG1CQUFPQSxDQUFDLDhFQUFTO0FBQzlCLElBQUlDLFVBQVVELG1CQUFPQSxDQUFDLGdGQUFVO0FBQ2hDLCtDQUErQyxHQUMvQywwRkFBMEYsR0FDMUYsdURBQXVELEdBQ3ZELFNBQVNKLGlCQUFpQk0sVUFBVSxhQUFhLEdBQWQsRUFBa0JDLEVBQUUsVUFBVSxHQUFYLEVBQWVDLEVBQUUsVUFBVSxHQUFYLEVBQWUsb0JBQW9CO0lBQ3ZHLDBDQUEwQztJQUMxQyxJQUFJLENBQUNGLFVBQVVHLEtBQUssQ0FBQ0MsTUFBTSxFQUFFLE9BQU87UUFBQ0g7UUFBR0M7S0FBRTtJQUUxQyxtQkFBbUI7SUFDbkIsSUFBSSxFQUNGRSxNQUFNLEVBQ1AsR0FBR0osVUFBVUcsS0FBSztJQUNuQkMsU0FBUyxPQUFPQSxXQUFXLFdBQVdBLFNBQVNDLFlBQVlEO0lBQzNELE1BQU1FLE9BQU9DLFlBQVlQO0lBQ3pCLElBQUksT0FBT0ksV0FBVyxVQUFVO1FBQzlCLE1BQU0sRUFDSkksYUFBYSxFQUNkLEdBQUdGO1FBQ0osTUFBTUcsY0FBY0QsY0FBY0UsV0FBVztRQUM3QyxJQUFJQztRQUNKLElBQUlQLFdBQVcsVUFBVTtZQUN2Qk8sWUFBWUwsS0FBS00sVUFBVTtRQUM3QixPQUFPO1lBQ0wsK0RBQStEO1lBQy9ELHVEQUF1RDtZQUN2RCwwQ0FBMEM7WUFDMUMsNERBQTREO1lBQzVE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QUNELE1BQU07UUFDVCxNQUFNLElBQUlXLE1BQU07SUFDbEI7SUFDQSxtRUFBbUU7SUFDbkUsT0FBT1g7QUFDVCIsInNvdXJjZXMiOlsid2VicGFjazovL2FpLW9zLW12cC8uL25vZGVfbW9kdWxlcy9yZWFjdC1kcmFnZ2FibGUvYnVpbGQvY2pzL3V0aWxzL3Bvc2l0aW9uRm5zLmpzP2E5ZDciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmNhbkRyYWdYID0gY2FuRHJhZ1g7XG5leHBvcnRzLmNhbkRyYWdZID0gY2FuRHJhZ1k7XG5leHBvcnRzLmNyZWF0ZUNvcmVEYXRhID0gY3JlYXRlQ29yZURhdGE7XG5leHBvcnRzLmNyZWF0ZURyYWdnYWJsZURhdGEgPSBjcmVhdGVEcmFnZ2FibGVEYXRhO1xuZXhwb3J0cy5nZXRCb3VuZFBvc2l0aW9uID0gZ2V0Qm91bmRQb3NpdGlvbjtcbmV4cG9ydHMuZ2V0Q29udHJvbFBvc2l0aW9uID0gZ2V0Q29udHJvbFBvc2l0aW9uO1xuZXhwb3J0cy5zbmFwVG9HcmlkID0gc25hcFRvR3JpZDtcbnZhciBfc2hpbXMgPSByZXF1aXJlKFwiLi9zaGltc1wiKTtcbnZhciBfZG9tRm5zID0gcmVxdWlyZShcIi4vZG9tRm5zXCIpO1xuLyo6OiBpbXBvcnQgdHlwZSBEcmFnZ2FibGUgZnJvbSAnLi4vRHJhZ2dhYmxlJzsqL1xuLyo6OiBpbXBvcnQgdHlwZSB7Qm91bmRzLCBDb250cm9sUG9zaXRpb24sIERyYWdnYWJsZURhdGEsIE1vdXNlVG91Y2hFdmVudH0gZnJvbSAnLi90eXBlcyc7Ki9cbi8qOjogaW1wb3J0IHR5cGUgRHJhZ2dhYmxlQ29yZSBmcm9tICcuLi9EcmFnZ2FibGVDb3JlJzsqL1xuZnVuY3Rpb24gZ2V0Qm91bmRQb3NpdGlvbihkcmFnZ2FibGUgLyo6IERyYWdnYWJsZSovLCB4IC8qOiBudW1iZXIqLywgeSAvKjogbnVtYmVyKi8pIC8qOiBbbnVtYmVyLCBudW1iZXJdKi97XG4gIC8vIElmIG5vIGJvdW5kcywgc2hvcnQtY2lyY3VpdCBhbmQgbW92ZSBvblxuICBpZiAoIWRyYWdnYWJsZS5wcm9wcy5ib3VuZHMpIHJldHVybiBbeCwgeV07XG5cbiAgLy8gQ2xvbmUgbmV3IGJvdW5kc1xuICBsZXQge1xuICAgIGJvdW5kc1xuICB9ID0gZHJhZ2dhYmxlLnByb3BzO1xuICBib3VuZHMgPSB0eXBlb2YgYm91bmRzID09PSAnc3RyaW5nJyA/IGJvdW5kcyA6IGNsb25lQm91bmRzKGJvdW5kcyk7XG4gIGNvbnN0IG5vZGUgPSBmaW5kRE9NTm9kZShkcmFnZ2FibGUpO1xuICBpZiAodHlwZW9mIGJvdW5kcyA9PT0gJ3N0cmluZycpIHtcbiAgICBjb25zdCB7XG4gICAgICBvd25lckRvY3VtZW50XG4gICAgfSA9IG5vZGU7XG4gICAgY29uc3Qgb3duZXJXaW5kb3cgPSBvd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuICAgIGxldCBib3VuZE5vZGU7XG4gICAgaWYgKGJvdW5kcyA9PT0gJ3BhcmVudCcpIHtcbiAgICAgIGJvdW5kTm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRmxvdyBhc3NpZ25zIHRoZSB3cm9uZyByZXR1cm4gdHlwZSAoTm9kZSkgZm9yIGdldFJvb3ROb2RlKCksXG4gICAgICAvLyBzbyB3ZSBjYXN0IGl0IHRvIG9uZSBvZiB0aGUgY29ycmVjdCB0eXBlcyAoRWxlbWVudCkuXG4gICAgICAvLyBUaGUgb3RoZXJzIGFyZSBEb2N1bWVudCBhbmQgU2hhZG93Um9vdC5cbiAgICAgIC8vIEFsbCB0aHJlZSBpbXBsZW1lbnQgcXVlcnlTZWxlY3RvcigpIHNvIGl0J3Mgc2FmZSB0byBjYWxsLlxuICAgICAgY29uc3Qgcm9vdE5vZGUgPSAoKG5vZGUuZ2V0Um9vdE5vZGUoKSAvKjogYW55Ki8pIC8qOiBFbGVtZW50Ki8pO1xuICAgICAgYm91bmROb2RlID0gcm9vdE5vZGUucXVlcnlTZWxlY3Rvcihib3VuZHMpO1xuICAgIH1cbiAgICBpZiAoIShib3VuZE5vZGUgaW5zdGFuY2VvZiBvd25lcldpbmRvdy5IVE1MRWxlbWVudCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQm91bmRzIHNlbGVjdG9yIFwiJyArIGJvdW5kcyArICdcIiBjb3VsZCBub3QgZmluZCBhbiBlbGVtZW50LicpO1xuICAgIH1cbiAgICBjb25zdCBib3VuZE5vZGVFbCAvKjogSFRNTEVsZW1lbnQqLyA9IGJvdW5kTm9kZTsgLy8gZm9yIEZsb3csIGNhbid0IHNlZW0gdG8gcmVmaW5lIGNvcnJlY3RseVxuICAgIGNvbnN0IG5vZGVTdHlsZSA9IG93bmVyV2luZG93LmdldENvbXB1dGVkU3R5bGUobm9kZSk7XG4gICAgY29uc3QgYm91bmROb2RlU3R5bGUgPSBvd25lcldpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGJvdW5kTm9kZUVsKTtcbiAgICAvLyBDb21wdXRlIGJvdW5kcy4gVGhpcyBpcyBhIHBhaW4gd2l0aCBwYWRkaW5nIGFuZCBvZmZzZXRzIGJ1dCB0aGlzIGdldHMgaXQgZXhhY3RseSByaWdodC5cbiAgICBib3VuZHMgPSB7XG4gICAgICBsZWZ0OiAtbm9kZS5vZmZzZXRMZWZ0ICsgKDAsIF9zaGltcy5pbnQpKGJvdW5kTm9kZVN0eWxlLnBhZGRpbmdMZWZ0KSArICgwLCBfc2hpbXMuaW50KShub2RlU3R5bGUubWFyZ2luTGVmdCksXG4gICAgICB0b3A6IC1ub2RlLm9mZnNldFRvcCArICgwLCBfc2hpbXMuaW50KShib3VuZE5vZGVTdHlsZS5wYWRkaW5nVG9wKSArICgwLCBfc2hpbXMuaW50KShub2RlU3R5bGUubWFyZ2luVG9wKSxcbiAgICAgIHJpZ2h0OiAoMCwgX2RvbUZucy5pbm5lcldpZHRoKShib3VuZE5vZGVFbCkgLSAoMCwgX2RvbUZucy5vdXRlcldpZHRoKShub2RlKSAtIG5vZGUub2Zmc2V0TGVmdCArICgwLCBfc2hpbXMuaW50KShib3VuZE5vZGVTdHlsZS5wYWRkaW5nUmlnaHQpIC0gKDAsIF9zaGltcy5pbnQpKG5vZGVTdHlsZS5tYXJnaW5SaWdodCksXG4gICAgICBib3R0b206ICgwLCBfZG9tRm5zLmlubmVySGVpZ2h0KShib3VuZE5vZGVFbCkgLSAoMCwgX2RvbUZucy5vdXRlckhlaWdodCkobm9kZSkgLSBub2RlLm9mZnNldFRvcCArICgwLCBfc2hpbXMuaW50KShib3VuZE5vZGVTdHlsZS5wYWRkaW5nQm90dG9tKSAtICgwLCBfc2hpbXMuaW50KShub2RlU3R5bGUubWFyZ2luQm90dG9tKVxuICAgIH07XG4gIH1cblxuICAvLyBLZWVwIHggYW5kIHkgYmVsb3cgcmlnaHQgYW5kIGJvdHRvbSBsaW1pdHMuLi5cbiAgaWYgKCgwLCBfc2hpbXMuaXNOdW0pKGJvdW5kcy5yaWdodCkpIHggPSBNYXRoLm1pbih4LCBib3VuZHMucmlnaHQpO1xuICBpZiAoKDAsIF9zaGltcy5pc051bSkoYm91bmRzLmJvdHRvbSkpIHkgPSBNYXRoLm1pbih5LCBib3VuZHMuYm90dG9tKTtcblxuICAvLyBCdXQgYWJvdmUgbGVmdCBhbmQgdG9wIGxpbWl0cy5cbiAgaWYgKCgwLCBfc2hpbXMuaXNOdW0pKGJvdW5kcy5sZWZ0KSkgeCA9IE1hdGgubWF4KHgsIGJvdW5kcy5sZWZ0KTtcbiAgaWYgKCgwLCBfc2hpbXMuaXNOdW0pKGJvdW5kcy50b3ApKSB5ID0gTWF0aC5tYXgoeSwgYm91bmRzLnRvcCk7XG4gIHJldHVybiBbeCwgeV07XG59XG5mdW5jdGlvbiBzbmFwVG9HcmlkKGdyaWQgLyo6IFtudW1iZXIsIG51bWJlcl0qLywgcGVuZGluZ1ggLyo6IG51bWJlciovLCBwZW5kaW5nWSAvKjogbnVtYmVyKi8pIC8qOiBbbnVtYmVyLCBudW1iZXJdKi97XG4gIGNvbnN0IHggPSBNYXRoLnJvdW5kKHBlbmRpbmdYIC8gZ3JpZFswXSkgKiBncmlkWzBdO1xuICBjb25zdCB5ID0gTWF0aC5yb3VuZChwZW5kaW5nWSAvIGdyaWRbMV0pICogZ3JpZFsxXTtcbiAgcmV0dXJuIFt4LCB5XTtcbn1cbmZ1bmN0aW9uIGNhbkRyYWdYKGRyYWdnYWJsZSAvKjogRHJhZ2dhYmxlKi8pIC8qOiBib29sZWFuKi97XG4gIHJldHVybiBkcmFnZ2FibGUucHJvcHMuYXhpcyA9PT0gJ2JvdGgnIHx8IGRyYWdnYWJsZS5wcm9wcy5heGlzID09PSAneCc7XG59XG5mdW5jdGlvbiBjYW5EcmFnWShkcmFnZ2FibGUgLyo6IERyYWdnYWJsZSovKSAvKjogYm9vbGVhbiove1xuICByZXR1cm4gZHJhZ2dhYmxlLnByb3BzLmF4aXMgPT09ICdib3RoJyB8fCBkcmFnZ2FibGUucHJvcHMuYXhpcyA9PT0gJ3knO1xufVxuXG4vLyBHZXQge3gsIHl9IHBvc2l0aW9ucyBmcm9tIGV2ZW50LlxuZnVuY3Rpb24gZ2V0Q29udHJvbFBvc2l0aW9uKGUgLyo6IE1vdXNlVG91Y2hFdmVudCovLCB0b3VjaElkZW50aWZpZXIgLyo6ID9udW1iZXIqLywgZHJhZ2dhYmxlQ29yZSAvKjogRHJhZ2dhYmxlQ29yZSovKSAvKjogP0NvbnRyb2xQb3NpdGlvbiove1xuICBjb25zdCB0b3VjaE9iaiA9IHR5cGVvZiB0b3VjaElkZW50aWZpZXIgPT09ICdudW1iZXInID8gKDAsIF9kb21GbnMuZ2V0VG91Y2gpKGUsIHRvdWNoSWRlbnRpZmllcikgOiBudWxsO1xuICBpZiAodHlwZW9mIHRvdWNoSWRlbnRpZmllciA9PT0gJ251bWJlcicgJiYgIXRvdWNoT2JqKSByZXR1cm4gbnVsbDsgLy8gbm90IHRoZSByaWdodCB0b3VjaFxuICBjb25zdCBub2RlID0gZmluZERPTU5vZGUoZHJhZ2dhYmxlQ29yZSk7XG4gIC8vIFVzZXIgY2FuIHByb3ZpZGUgYW4gb2Zmc2V0UGFyZW50IGlmIGRlc2lyZWQuXG4gIGNvbnN0IG9mZnNldFBhcmVudCA9IGRyYWdnYWJsZUNvcmUucHJvcHMub2Zmc2V0UGFyZW50IHx8IG5vZGUub2Zmc2V0UGFyZW50IHx8IG5vZGUub3duZXJEb2N1bWVudC5ib2R5O1xuICByZXR1cm4gKDAsIF9kb21GbnMub2Zmc2V0WFlGcm9tUGFyZW50KSh0b3VjaE9iaiB8fCBlLCBvZmZzZXRQYXJlbnQsIGRyYWdnYWJsZUNvcmUucHJvcHMuc2NhbGUpO1xufVxuXG4vLyBDcmVhdGUgYW4gZGF0YSBvYmplY3QgZXhwb3NlZCBieSA8RHJhZ2dhYmxlQ29yZT4ncyBldmVudHNcbmZ1bmN0aW9uIGNyZWF0ZUNvcmVEYXRhKGRyYWdnYWJsZSAvKjogRHJhZ2dhYmxlQ29yZSovLCB4IC8qOiBudW1iZXIqLywgeSAvKjogbnVtYmVyKi8pIC8qOiBEcmFnZ2FibGVEYXRhKi97XG4gIGNvbnN0IGlzU3RhcnQgPSAhKDAsIF9zaGltcy5pc051bSkoZHJhZ2dhYmxlLmxhc3RYKTtcbiAgY29uc3Qgbm9kZSA9IGZpbmRET01Ob2RlKGRyYWdnYWJsZSk7XG4gIGlmIChpc1N0YXJ0KSB7XG4gICAgLy8gSWYgdGhpcyBpcyBvdXIgZmlyc3QgbW92ZSwgdXNlIHRoZSB4IGFuZCB5IGFzIGxhc3QgY29vcmRzLlxuICAgIHJldHVybiB7XG4gICAgICBub2RlLFxuICAgICAgZGVsdGFYOiAwLFxuICAgICAgZGVsdGFZOiAwLFxuICAgICAgbGFzdFg6IHgsXG4gICAgICBsYXN0WTogeSxcbiAgICAgIHgsXG4gICAgICB5XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICAvLyBPdGhlcndpc2UgY2FsY3VsYXRlIHByb3BlciB2YWx1ZXMuXG4gICAgcmV0dXJuIHtcbiAgICAgIG5vZGUsXG4gICAgICBkZWx0YVg6IHggLSBkcmFnZ2FibGUubGFzdFgsXG4gICAgICBkZWx0YVk6IHkgLSBkcmFnZ2FibGUubGFzdFksXG4gICAgICBsYXN0WDogZHJhZ2dhYmxlLmxhc3RYLFxuICAgICAgbGFzdFk6IGRyYWdnYWJsZS5sYXN0WSxcbiAgICAgIHgsXG4gICAgICB5XG4gICAgfTtcbiAgfVxufVxuXG4vLyBDcmVhdGUgYW4gZGF0YSBleHBvc2VkIGJ5IDxEcmFnZ2FibGU+J3MgZXZlbnRzXG5mdW5jdGlvbiBjcmVhdGVEcmFnZ2FibGVEYXRhKGRyYWdnYWJsZSAvKjogRHJhZ2dhYmxlKi8sIGNvcmVEYXRhIC8qOiBEcmFnZ2FibGVEYXRhKi8pIC8qOiBEcmFnZ2FibGVEYXRhKi97XG4gIGNvbnN0IHNjYWxlID0gZHJhZ2dhYmxlLnByb3BzLnNjYWxlO1xuICByZXR1cm4ge1xuICAgIG5vZGU6IGNvcmVEYXRhLm5vZGUsXG4gICAgeDogZHJhZ2dhYmxlLnN0YXRlLnggKyBjb3JlRGF0YS5kZWx0YVggLyBzY2FsZSxcbiAgICB5OiBkcmFnZ2FibGUuc3RhdGUueSArIGNvcmVEYXRhLmRlbHRhWSAvIHNjYWxlLFxuICAgIGRlbHRhWDogY29yZURhdGEuZGVsdGFYIC8gc2NhbGUsXG4gICAgZGVsdGFZOiBjb3JlRGF0YS5kZWx0YVkgLyBzY2FsZSxcbiAgICBsYXN0WDogZHJhZ2dhYmxlLnN0YXRlLngsXG4gICAgbGFzdFk6IGRyYWdnYWJsZS5zdGF0ZS55XG4gIH07XG59XG5cbi8vIEEgbG90IGZhc3RlciB0aGFuIHN0cmluZ2lmeS9wYXJzZVxuZnVuY3Rpb24gY2xvbmVCb3VuZHMoYm91bmRzIC8qOiBCb3VuZHMqLykgLyo6IEJvdW5kcyove1xuICByZXR1cm4ge1xuICAgIGxlZnQ6IGJvdW5kcy5sZWZ0LFxuICAgIHRvcDogYm91bmRzLnRvcCxcbiAgICByaWdodDogYm91bmRzLnJpZ2h0LFxuICAgIGJvdHRvbTogYm91bmRzLmJvdHRvbVxuICB9O1xufVxuZnVuY3Rpb24gZmluZERPTU5vZGUoZHJhZ2dhYmxlIC8qOiBEcmFnZ2FibGUgfCBEcmFnZ2FibGVDb3JlKi8pIC8qOiBIVE1MRWxlbWVudCove1xuICBjb25zdCBub2RlID0gZHJhZ2dhYmxlLmZpbmRET01Ob2RlKCk7XG4gIGlmICghbm9kZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignPERyYWdnYWJsZUNvcmU+OiBVbm1vdW50ZWQgZHVyaW5nIGV2ZW50IScpO1xuICB9XG4gIC8vICRGbG93SWdub3JlIHdlIGNhbid0IGFzc2VydCBvbiBIVE1MRWxlbWVudCBkdWUgdG8gdGVzdHMuLi4gRklYTUVcbiAgcmV0dXJuIG5vZGU7XG59Il0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiY2FuRHJhZ1giLCJjYW5EcmFnWSIsImNyZWF0ZUNvcmVEYXRhIiwiY3JlYXRlRHJhZ2dhYmxlRGF0YSIsImdldEJvdW5kUG9zaXRpb24iLCJnZXRDb250cm9sUG9zaXRpb24iLCJzbmFwVG9HcmlkIiwiX3NoaW1zIiwicmVxdWlyZSIsIl9kb21GbnMiLCJkcmFnZ2FibGUiLCJ4IiwieSIsInByb3BzIiwiYm91bmRzIiwiY2xvbmVCb3VuZHMiLCJub2RlIiwiZmluZERPTU5vZGUiLCJvd25lckRvY3VtZW50Iiwib3duZXJXaW5kb3ciLCJkZWZhdWx0VmlldyIsImJvdW5kTm9kZSIsInBhcmVudE5vZGUiLCJyb290Tm9kZSIsImdldFJvb3ROb2RlIiwicXVlcnlTZWxlY3RvciIsIkhUTUxFbGVtZW50IiwiRXJyb3IiLCJib3VuZE5vZGVFbCIsIm5vZGVTdHlsZSIsImdldENvbXB1dGVkU3R5bGUiLCJib3VuZE5vZGVTdHlsZSIsImxlZnQiLCJvZmZzZXRMZWZ0IiwiaW50IiwicGFkZGluZ0xlZnQiLCJtYXJnaW5MZWZ0IiwidG9wIiwib2Zmc2V0VG9wIiwicGFkZGluZ1RvcCIsIm1hcmdpblRvcCIsInJpZ2h0IiwiaW5uZXJXaWR0aCIsIm91dGVyV2lkdGgiLCJwYWRkaW5nUmlnaHQiLCJtYXJnaW5SaWdodCIsImJvdHRvbSIsImlubmVySGVpZ2h0Iiwib3V0ZXJIZWlnaHQiLCJwYWRkaW5nQm90dG9tIiwibWFyZ2luQm90dG9tIiwiaXNOdW0iLCJNYXRoIiwibWluIiwibWF4IiwiZ3JpZCIsInBlbmRpbmdYIiwicGVuZGluZ1kiLCJyb3VuZCIsImF4aXMiLCJlIiwidG91Y2hJZGVudGlmaWVyIiwiZHJhZ2dhYmxlQ29yZSIsInRvdWNoT2JqIiwiZ2V0VG91Y2giLCJvZmZzZXRQYXJlbnQiLCJib2R5Iiwib2Zmc2V0WFlGcm9tUGFyZW50Iiwic2NhbGUiLCJpc1N0YXJ0IiwibGFzdFgiLCJkZWx0YVgiLCJkZWx0YVkiLCJsYXN0WSIsImNvcmVEYXRhIiwic3RhdGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-draggable/build/cjs/utils/positionFns.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-draggable/build/cjs/utils/shims.js":
/*!***************************************************************!*\
  !*** ./node_modules/react-draggable/build/cjs/utils/shims.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.dontSetMe = dontSetMe;\nexports.findInArray = findInArray;\nexports.int = int;\nexports.isFunction = isFunction;\nexports.isNum = isNum;\n// @credits https://gist.github.com/rogozhnikoff/a43cfed27c41e4e68cdc\nfunction findInArray(array /*: Array<any> | TouchList*/ , callback /*: Function*/ ) /*: any*/ {\n    for(let i = 0, length = array.length; i < length; i++){\n        if (callback.apply(callback, [\n            array[i],\n            i,\n            array\n        ])) return array[i];\n    }\n}\nfunction isFunction(func /*: any*/ ) /*: boolean %checks*/ {\n    // $FlowIgnore[method-unbinding]\n    return typeof func === \"function\" || Object.prototype.toString.call(func) === \"[object Function]\";\n}\nfunction isNum(num /*: any*/ ) /*: boolean %checks*/ {\n    return typeof num === \"number\" && !isNaN(num);\n}\nfunction int(a /*: string*/ ) /*: number*/ {\n    return parseInt(a, 10);\n}\nfunction dontSetMe(props /*: Object*/ , propName /*: string*/ , componentName /*: string*/ ) /*: ?Error*/ {\n    if (props[propName]) {\n        return new Error(`Invalid prop ${propName} passed to ${componentName} - do not set this, set it on the child.`);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtZHJhZ2dhYmxlL2J1aWxkL2Nqcy91dGlscy9zaGltcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViQSw4Q0FBNkM7SUFDM0NHLE9BQU87QUFDVCxDQUFDLEVBQUM7QUFDRkQsaUJBQWlCLEdBQUdFO0FBQ3BCRixtQkFBbUIsR0FBR0c7QUFDdEJILFdBQVcsR0FBR0k7QUFDZEosa0JBQWtCLEdBQUdLO0FBQ3JCTCxhQUFhLEdBQUdNO0FBQ2hCLHFFQUFxRTtBQUNyRSxTQUFTSCxZQUFZSSxNQUFNLDBCQUEwQixHQUEzQixFQUErQkMsU0FBUyxZQUFZLEdBQWIsRUFBaUIsT0FBTztJQUN2RixJQUFLLElBQUlDLElBQUksR0FBR0MsU0FBU0gsTUFBTUcsTUFBTSxFQUFFRCxJQUFJQyxRQUFRRCxJQUFLO1FBQ3RELElBQUlELFNBQVNHLEtBQUssQ0FBQ0gsVUFBVTtZQUFDRCxLQUFLLENBQUNFLEVBQUU7WUFBRUE7WUFBR0Y7U0FBTSxHQUFHLE9BQU9BLEtBQUssQ0FBQ0UsRUFBRTtJQUNyRTtBQUNGO0FBQ0EsU0FBU0osV0FBV08sS0FBSyxPQUFPLEdBQVIsRUFBWSxtQkFBbUI7SUFDckQsZ0NBQWdDO0lBQ2hDLE9BQU8sT0FBT0EsU0FBUyxjQUFjZCxPQUFPZSxTQUFTLENBQUNDLFFBQVEsQ0FBQ0MsSUFBSSxDQUFDSCxVQUFVO0FBQ2hGO0FBQ0EsU0FBU04sTUFBTVUsSUFBSSxPQUFPLEdBQVIsRUFBWSxtQkFBbUI7SUFDL0MsT0FBTyxPQUFPQSxRQUFRLFlBQVksQ0FBQ0MsTUFBTUQ7QUFDM0M7QUFDQSxTQUFTWixJQUFJYyxFQUFFLFVBQVUsR0FBWCxFQUFlLFVBQVU7SUFDckMsT0FBT0MsU0FBU0QsR0FBRztBQUNyQjtBQUNBLFNBQVNoQixVQUFVa0IsTUFBTSxVQUFVLEdBQVgsRUFBZUMsU0FBUyxVQUFVLEdBQVgsRUFBZUMsY0FBYyxVQUFVLEdBQVgsRUFBZSxVQUFVO0lBQ2xHLElBQUlGLEtBQUssQ0FBQ0MsU0FBUyxFQUFFO1FBQ25CLE9BQU8sSUFBSUUsTUFBTSxDQUFDLGFBQWEsRUFBRUYsU0FBUyxXQUFXLEVBQUVDLGNBQWMsd0NBQXdDLENBQUM7SUFDaEg7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL2FpLW9zLW12cC8uL25vZGVfbW9kdWxlcy9yZWFjdC1kcmFnZ2FibGUvYnVpbGQvY2pzL3V0aWxzL3NoaW1zLmpzP2Q5ZTciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRvbnRTZXRNZSA9IGRvbnRTZXRNZTtcbmV4cG9ydHMuZmluZEluQXJyYXkgPSBmaW5kSW5BcnJheTtcbmV4cG9ydHMuaW50ID0gaW50O1xuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcbmV4cG9ydHMuaXNOdW0gPSBpc051bTtcbi8vIEBjcmVkaXRzIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3JvZ296aG5pa29mZi9hNDNjZmVkMjdjNDFlNGU2OGNkY1xuZnVuY3Rpb24gZmluZEluQXJyYXkoYXJyYXkgLyo6IEFycmF5PGFueT4gfCBUb3VjaExpc3QqLywgY2FsbGJhY2sgLyo6IEZ1bmN0aW9uKi8pIC8qOiBhbnkqL3tcbiAgZm9yIChsZXQgaSA9IDAsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGNhbGxiYWNrLmFwcGx5KGNhbGxiYWNrLCBbYXJyYXlbaV0sIGksIGFycmF5XSkpIHJldHVybiBhcnJheVtpXTtcbiAgfVxufVxuZnVuY3Rpb24gaXNGdW5jdGlvbihmdW5jIC8qOiBhbnkqLykgLyo6IGJvb2xlYW4gJWNoZWNrcyove1xuICAvLyAkRmxvd0lnbm9yZVttZXRob2QtdW5iaW5kaW5nXVxuICByZXR1cm4gdHlwZW9mIGZ1bmMgPT09ICdmdW5jdGlvbicgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGZ1bmMpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xufVxuZnVuY3Rpb24gaXNOdW0obnVtIC8qOiBhbnkqLykgLyo6IGJvb2xlYW4gJWNoZWNrcyove1xuICByZXR1cm4gdHlwZW9mIG51bSA9PT0gJ251bWJlcicgJiYgIWlzTmFOKG51bSk7XG59XG5mdW5jdGlvbiBpbnQoYSAvKjogc3RyaW5nKi8pIC8qOiBudW1iZXIqL3tcbiAgcmV0dXJuIHBhcnNlSW50KGEsIDEwKTtcbn1cbmZ1bmN0aW9uIGRvbnRTZXRNZShwcm9wcyAvKjogT2JqZWN0Ki8sIHByb3BOYW1lIC8qOiBzdHJpbmcqLywgY29tcG9uZW50TmFtZSAvKjogc3RyaW5nKi8pIC8qOiA/RXJyb3IqL3tcbiAgaWYgKHByb3BzW3Byb3BOYW1lXSkge1xuICAgIHJldHVybiBuZXcgRXJyb3IoYEludmFsaWQgcHJvcCAke3Byb3BOYW1lfSBwYXNzZWQgdG8gJHtjb21wb25lbnROYW1lfSAtIGRvIG5vdCBzZXQgdGhpcywgc2V0IGl0IG9uIHRoZSBjaGlsZC5gKTtcbiAgfVxufSJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImRvbnRTZXRNZSIsImZpbmRJbkFycmF5IiwiaW50IiwiaXNGdW5jdGlvbiIsImlzTnVtIiwiYXJyYXkiLCJjYWxsYmFjayIsImkiLCJsZW5ndGgiLCJhcHBseSIsImZ1bmMiLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsImNhbGwiLCJudW0iLCJpc05hTiIsImEiLCJwYXJzZUludCIsInByb3BzIiwicHJvcE5hbWUiLCJjb21wb25lbnROYW1lIiwiRXJyb3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-draggable/build/cjs/utils/shims.js\n");

/***/ })

};
;